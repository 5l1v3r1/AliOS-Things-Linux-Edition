From bb07deaec71371bc612c3117f8858271c96273f8 Mon Sep 17 00:00:00 2001
From: Benxi Liu <bxliu@linux.alibaba.com>
Date: Fri, 1 Feb 2019 14:29:54 +0800
Subject: [PATCH] Fix integer overflows in internal memalign and malloc [BZ
 #22343] [BZ #22774]

When posix_memalign is called with an alignment less than MALLOC_ALIGNMENT
and a requested size close to SIZE_MAX, it falls back to malloc code
(because the alignment of a block returned by malloc is sufficient to
satisfy the call).  In this case, an integer overflow in _int_malloc leads
to posix_memalign incorrectly returning successfully.

Upon fixing this and writing a somewhat thorough regression test, it was
discovered that when posix_memalign is called with an alignment larger than
MALLOC_ALIGNMENT (so it uses _int_memalign instead) and a requested size
close to SIZE_MAX, a different integer overflow in _int_memalign leads to
posix_memalign incorrectly returning successfully.

Both integer overflows affect other memory allocation functions that use
_int_malloc (one affected malloc in x86) or _int_memalign as well.

This commit fixes both integer overflows.  In addition to this, it adds a
regression test to guard against false successful allocations by the
following memory allocation functions when called with too-large allocation
sizes and, where relevant, various valid alignments:
malloc, realloc, calloc, memalign, posix_memalign, aligned_alloc, valloc,
and pvalloc.

(cherry picked from commit 8e448310d74b283c5cd02b9ed7fb997b47bf9b22)

The patch comes from:
https://sourceware.org/git/?p=glibc.git;a=commit;h=9331dbdcd7aa8e997eb4caa9b1b0cb6c804320c8

The related new test is not added to this patch.

CVE: CVE-2018-6485 CVE-2018-6551
Upstream-Status: Backport

Signed-off-by: Benxi Liu <bxliu@linux.alibaba.com>
---
 ChangeLog       | 11 +++++++++++
 NEWS            | 10 ++++++++++
 malloc/malloc.c | 30 ++++++++++++++++++++++--------
 3 files changed, 43 insertions(+), 8 deletions(-)

diff --git a/ChangeLog b/ChangeLog
index 01c28b1..da13276 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,14 @@
+2018-01-18  Arjun Shankar  <arjun@redhat.com>
+
+	[BZ #22343]
+	[BZ #22774]
+	CVE-2018-6485
+	CVE-2018-6551
+	* malloc/malloc.c (checked_request2size): call REQUEST_OUT_OF_RANGE
+	after padding.
+	(_int_memalign): check for integer overflow before calling
+	_int_malloc.
+
 2018-01-12  Dmitry V. Levin  <ldv@altlinux.org>
 
 	[BZ #22679]
diff --git a/NEWS b/NEWS
index b489c06..ddce46a 100644
--- a/NEWS
+++ b/NEWS
@@ -105,6 +105,14 @@ Security related changes:
   succeeds without returning an absolute path due to unexpected behaviour
   of the Linux kernel getcwd syscall.  Reported by halfdog.
 
+  CVE-2018-6485: The posix_memalign and memalign functions, when called with
+  an object size near the value of SIZE_MAX, would return a pointer to a
+  buffer which is too small, instead of NULL.  Reported by Jakub Wilk.
+
+  CVE-2018-6551: The malloc function, when called with an object size near
+  the value of SIZE_MAX, would return a pointer to a buffer which is too
+  small, instead of NULL.
+
 The following bugs are resolved with this release:
 
   [1170] localedata: ne_NP: update Nepali locale definition file
@@ -344,8 +352,10 @@ The following bugs are resolved with this release:
   [20350] libc: There is no test for p{read,write}64
   [20357] math: Incorrect cos result for 1.5174239687223976
   [20384] build: Don't run libmvec-sincos-avx* tests on non avx machines
+  [22343] malloc: Integer overflow in posix_memalign (CVE-2018-6485)
   [22679] getcwd(3) can succeed without returning an absolute path
     (CVE-2018-1000001)
+  [22774] malloc: Integer overflow in malloc (CVE-2018-6551)
 
 Version 2.23
 
diff --git a/malloc/malloc.c b/malloc/malloc.c
index 1f5f166..1912c08 100644
--- a/malloc/malloc.c
+++ b/malloc/malloc.c
@@ -1245,14 +1245,21 @@ nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    MINSIZE :                                                      \
    ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)
 
-/*  Same, except also perform argument check */
-
-#define checked_request2size(req, sz)                             \
-  if (REQUEST_OUT_OF_RANGE (req)) {					      \
-      __set_errno (ENOMEM);						      \
-      return 0;								      \
-    }									      \
-  (sz) = request2size (req);
+/* Same, except also perform an argument and result check.  First, we check
+   that the padding done by request2size didn't result in an integer
+   overflow.  Then we check (using REQUEST_OUT_OF_RANGE) that the resulting
+   size isn't so large that a later alignment would lead to another integer
+   overflow.  */
+#define checked_request2size(req, sz) \
+({				    \
+  (sz) = request2size (req);	    \
+  if (((sz) < (req))		    \
+      || REQUEST_OUT_OF_RANGE (sz)) \
+    {				    \
+      __set_errno (ENOMEM);	    \
+      return 0;			    \
+    }				    \
+})
 
 /*
    --------------- Physical chunk operations ---------------
@@ -4451,6 +4458,13 @@ _int_memalign (mstate av, size_t alignment, size_t bytes)
    */
 
 
+  /* Check for overflow.  */
+  if (nb > SIZE_MAX - alignment - MINSIZE)
+    {
+      __set_errno (ENOMEM);
+      return 0;
+    }
+
   /* Call malloc with worst case padding to hit alignment. */
 
   m = (char *) (_int_malloc (av, nb + alignment + MINSIZE));
-- 
2.7.4

