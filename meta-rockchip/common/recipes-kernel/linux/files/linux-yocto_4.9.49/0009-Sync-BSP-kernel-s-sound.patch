From 66c780057276c9220c732ce4afad086c237579cd Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Thu, 31 May 2018 20:03:51 +0800
Subject: [PATCH 09/14] Sync BSP kernel's sound

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 include/linux/rockchip/grf.h              |  700 +++++++
 sound/soc/codecs/Kconfig                  |    5 +
 sound/soc/codecs/Makefile                 |    2 +
 sound/soc/codecs/rk3308_codec.c           | 2868 +++++++++++++++++++++++++++++
 sound/soc/codecs/rk3308_codec.h           | 1024 ++++++++++
 sound/soc/codecs/rk3308_codec_provider.h  |   33 +
 sound/soc/rockchip/Kconfig                |   16 +
 sound/soc/rockchip/Makefile               |    4 +
 sound/soc/rockchip/rockchip_i2s_tdm.c     | 1318 +++++++++++++
 sound/soc/rockchip/rockchip_i2s_tdm.h     |  276 +++
 sound/soc/rockchip/rockchip_multicodecs.c |  227 +++
 11 files changed, 6473 insertions(+)
 create mode 100644 include/linux/rockchip/grf.h
 create mode 100644 sound/soc/codecs/rk3308_codec.c
 create mode 100644 sound/soc/codecs/rk3308_codec.h
 create mode 100644 sound/soc/codecs/rk3308_codec_provider.h
 create mode 100644 sound/soc/rockchip/rockchip_i2s_tdm.c
 create mode 100644 sound/soc/rockchip/rockchip_i2s_tdm.h
 create mode 100644 sound/soc/rockchip/rockchip_multicodecs.c

diff --git a/include/linux/rockchip/grf.h b/include/linux/rockchip/grf.h
new file mode 100644
index 000000000000..fae51232297c
--- /dev/null
+++ b/include/linux/rockchip/grf.h
@@ -0,0 +1,700 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __MACH_ROCKCHIP_GRF_H
+#define __MACH_ROCKCHIP_GRF_H
+
+#define RK3188_GRF_GPIO0L_DIR           0x0000
+#define RK3188_GRF_GPIO0H_DIR           0x0004
+#define RK3188_GRF_GPIO1L_DIR           0x0008
+#define RK3188_GRF_GPIO1H_DIR           0x000c
+#define RK3188_GRF_GPIO2L_DIR           0x0010
+#define RK3188_GRF_GPIO2H_DIR           0x0014
+#define RK3188_GRF_GPIO3L_DIR           0x0018
+#define RK3188_GRF_GPIO3H_DIR           0x001c
+#define RK3188_GRF_GPIO0L_DO            0x0020
+#define RK3188_GRF_GPIO0H_DO            0x0024
+#define RK3188_GRF_GPIO1L_DO            0x0028
+#define RK3188_GRF_GPIO1H_DO            0x002c
+#define RK3188_GRF_GPIO2L_DO            0x0030
+#define RK3188_GRF_GPIO2H_DO            0x0034
+#define RK3188_GRF_GPIO3L_DO            0x0038
+#define RK3188_GRF_GPIO3H_DO            0x003c
+#define RK3188_GRF_GPIO0L_EN            0x0040
+#define RK3188_GRF_GPIO0H_EN            0x0044
+#define RK3188_GRF_GPIO1L_EN            0x0048
+#define RK3188_GRF_GPIO1H_EN            0x004c
+#define RK3188_GRF_GPIO2L_EN            0x0050
+#define RK3188_GRF_GPIO2H_EN            0x0054
+#define RK3188_GRF_GPIO3L_EN            0x0058
+#define RK3188_GRF_GPIO3H_EN            0x005c
+
+#define RK3188_GRF_GPIO0C_IOMUX         0x0068
+#define RK3188_GRF_GPIO0D_IOMUX         0x006c
+#define RK3188_GRF_GPIO1A_IOMUX         0x0070
+#define RK3188_GRF_GPIO1B_IOMUX         0x0074
+#define RK3188_GRF_GPIO1C_IOMUX         0x0078
+#define RK3188_GRF_GPIO1D_IOMUX         0x007c
+#define RK3188_GRF_GPIO2A_IOMUX         0x0080
+#define RK3188_GRF_GPIO2B_IOMUX         0x0084
+#define RK3188_GRF_GPIO2C_IOMUX         0x0088
+#define RK3188_GRF_GPIO2D_IOMUX         0x008c
+#define RK3188_GRF_GPIO3A_IOMUX         0x0090
+#define RK3188_GRF_GPIO3B_IOMUX         0x0094
+#define RK3188_GRF_GPIO3C_IOMUX         0x0098
+#define RK3188_GRF_GPIO3D_IOMUX         0x009c
+#define RK3188_GRF_SOC_CON0             0x00a0
+#define RK3188_GRF_SOC_CON1             0x00a4
+#define RK3188_GRF_SOC_CON2             0x00a8
+#define RK3188_GRF_SOC_STATUS0          0x00ac
+#define RK3188_GRF_DMAC1_CON0           0x00b0
+#define RK3188_GRF_DMAC1_CON1           0x00b4
+#define RK3188_GRF_DMAC1_CON2           0x00b8
+#define RK3188_GRF_DMAC2_CON0           0x00bc
+#define RK3188_GRF_DMAC2_CON1           0x00c0
+#define RK3188_GRF_DMAC2_CON2           0x00c4
+#define RK3188_GRF_DMAC2_CON3           0x00c8
+#define RK3188_GRF_CPU_CON0             0x00cc
+#define RK3188_GRF_CPU_CON1             0x00d0
+#define RK3188_GRF_CPU_CON2             0x00d4
+#define RK3188_GRF_CPU_CON3             0x00d8
+#define RK3188_GRF_CPU_CON4             0x00dc
+#define RK3188_GRF_CPU_CON5             0x00e0
+
+#define RK3188_GRF_DDRC_CON0            0x00ec
+#define RK3188_GRF_DDRC_STAT            0x00f0
+#define RK3188_GRF_IO_CON0              0x00f4
+#define RK3188_GRF_IO_CON1              0x00f8
+#define RK3188_GRF_IO_CON2              0x00fc
+#define RK3188_GRF_IO_CON3              0x0100
+#define RK3188_GRF_IO_CON4              0x0104
+#define RK3188_GRF_SOC_STATUS1          0x0108
+#define RK3188_GRF_UOC0_CON0            0x010c
+#define RK3188_GRF_UOC0_CON1            0x0110
+#define RK3188_GRF_UOC0_CON2            0x0114
+#define RK3188_GRF_UOC0_CON3            0x0118
+#define RK3188_GRF_UOC1_CON0            0x011c
+#define RK3188_GRF_UOC1_CON1            0x0120
+#define RK3188_GRF_UOC1_CON2            0x0124
+#define RK3188_GRF_UOC1_CON3            0x0128
+#define RK3188_GRF_UOC2_CON0            0x012c
+#define RK3188_GRF_UOC2_CON1            0x0130
+
+#define RK3188_GRF_UOC3_CON0            0x0138
+#define RK3188_GRF_UOC3_CON1            0x013c
+#define RK3188_GRF_EHCI_STAT            0x0140
+#define RK3188_GRF_OS_REG0              0x0144
+#define RK3188_GRF_OS_REG1              0x0148
+#define RK3188_GRF_OS_REG2              0x014c
+#define RK3188_GRF_OS_REG3              0x0150
+#define RK3188_GRF_OS_REG4              0x0154
+#define RK3188_GRF_OS_REG5              0x0158
+#define RK3188_GRF_OS_REG6              0x015c
+#define RK3188_GRF_OS_REG7              0x0160
+#define RK3188_GRF_GPIO0B_PULL          0x0164
+#define RK3188_GRF_GPIO0C_PULL          0x0168
+#define RK3188_GRF_GPIO0D_PULL          0x016c
+#define RK3188_GRF_GPIO1A_PULL          0x0170
+#define RK3188_GRF_GPIO1B_PULL          0x0174
+#define RK3188_GRF_GPIO1C_PULL          0x0178
+#define RK3188_GRF_GPIO1D_PULL          0x017c
+#define RK3188_GRF_GPIO2A_PULL          0x0180
+#define RK3188_GRF_GPIO2B_PULL          0x0184
+#define RK3188_GRF_GPIO2C_PULL          0x0188
+#define RK3188_GRF_GPIO2D_PULL          0x018c
+#define RK3188_GRF_GPIO3A_PULL          0x0190
+#define RK3188_GRF_GPIO3B_PULL          0x0194
+#define RK3188_GRF_GPIO3C_PULL          0x0198
+#define RK3188_GRF_GPIO3D_PULL          0x019c
+#define RK3188_GRF_FLASH_DATA_PULL      0x01a0
+#define RK3188_GRF_FLASH_CMD_PULL       0x01a4
+
+
+#define RK3288_GRF_GPIO0_A_IOMUX	0x0084
+#define RK3288_GRF_GPIO0_B_IOMUX	0x0088
+#define RK3288_GRF_GPIO0_C_IOMUX	0x008c
+
+#define RK3288_GRF_GPIO1D_IOMUX         0x000c
+#define RK3288_GRF_GPIO2A_IOMUX         0x0010
+#define RK3288_GRF_GPIO2B_IOMUX         0x0014
+#define RK3288_GRF_GPIO2C_IOMUX         0x0018
+
+#define RK3288_GRF_GPIO3A_IOMUX         0x0020
+#define RK3288_GRF_GPIO3B_IOMUX         0x0024
+#define RK3288_GRF_GPIO3C_IOMUX         0x0028
+#define RK3288_GRF_GPIO3DL_IOMUX        0x002c
+#define RK3288_GRF_GPIO3DH_IOMUX        0x0030
+#define RK3288_GRF_GPIO4AL_IOMUX        0x0034
+#define RK3288_GRF_GPIO4AH_IOMUX        0x0038
+#define RK3288_GRF_GPIO4BL_IOMUX        0x003c
+
+#define RK3288_GRF_GPIO4C_IOMUX         0x0044
+#define RK3288_GRF_GPIO4D_IOMUX         0x0048
+
+#define RK3288_GRF_GPIO5B_IOMUX         0x0050
+#define RK3288_GRF_GPIO5C_IOMUX         0x0054
+
+#define RK3288_GRF_GPIO6A_IOMUX         0x005c
+#define RK3288_GRF_GPIO6B_IOMUX         0x0060
+#define RK3288_GRF_GPIO6C_IOMUX         0x0064
+
+#define RK3288_GRF_GPIO7A_IOMUX         0x006c
+#define RK3288_GRF_GPIO7B_IOMUX         0x0070
+#define RK3288_GRF_GPIO7CL_IOMUX        0x0074
+#define RK3288_GRF_GPIO7CH_IOMUX        0x0078
+
+#define RK3288_GRF_GPIO8A_IOMUX         0x0080
+#define RK3288_GRF_GPIO8B_IOMUX         0x0084
+
+#define RK3288_GRF_GPIO1H_SR            0x0104
+#define RK3288_GRF_GPIO2L_SR            0x0108
+#define RK3288_GRF_GPIO2H_SR            0x010c
+#define RK3288_GRF_GPIO3L_SR            0x0110
+#define RK3288_GRF_GPIO3H_SR            0x0114
+#define RK3288_GRF_GPIO4L_SR            0x0118
+#define RK3288_GRF_GPIO4H_SR            0x011c
+#define RK3288_GRF_GPIO5L_SR            0x0120
+#define RK3288_GRF_GPIO5H_SR            0x0124
+#define RK3288_GRF_GPIO6L_SR            0x0128
+#define RK3288_GRF_GPIO6H_SR            0x012c
+#define RK3288_GRF_GPIO7L_SR            0x0130
+#define RK3288_GRF_GPIO7H_SR            0x0134
+#define RK3288_GRF_GPIO8L_SR            0x0138
+
+#define RK3288_GRF_GPIO1D_P             0x014c
+#define RK3288_GRF_GPIO2A_P             0x0150
+#define RK3288_GRF_GPIO2B_P             0x0154
+#define RK3288_GRF_GPIO2C_P             0x0158
+
+#define RK3288_GRF_GPIO3A_P             0x0160
+#define RK3288_GRF_GPIO3B_P             0x0164
+#define RK3288_GRF_GPIO3C_P             0x0168
+#define RK3288_GRF_GPIO3D_P             0x016c
+#define RK3288_GRF_GPIO4A_P             0x0170
+#define RK3288_GRF_GPIO4B_P             0x0174
+#define RK3288_GRF_GPIO4C_P             0x0178
+#define RK3288_GRF_GPIO4D_P             0x017c
+
+#define RK3288_GRF_GPIO5B_P             0x0184
+#define RK3288_GRF_GPIO5C_P             0x0188
+
+#define RK3288_GRF_GPIO6A_P             0x0190
+#define RK3288_GRF_GPIO6B_P             0x0194
+#define RK3288_GRF_GPIO6C_P             0x0198
+
+#define RK3288_GRF_GPIO7A_P             0x01a0
+#define RK3288_GRF_GPIO7B_P             0x01a4
+#define RK3288_GRF_GPIO7C_P             0x01a8
+
+#define RK3288_GRF_GPIO8A_P             0x01b0
+#define RK3288_GRF_GPIO8B_P             0x01b4
+
+#define RK3288_GRF_GPIO1D_E             0x01cc
+#define RK3288_GRF_GPIO2A_E             0x01d0
+#define RK3288_GRF_GPIO2B_E             0x01d4
+#define RK3288_GRF_GPIO2C_E             0x01d8
+
+#define RK3288_GRF_GPIO3A_E             0x01e0
+#define RK3288_GRF_GPIO3B_E             0x01e4
+#define RK3288_GRF_GPIO3C_E             0x01e8
+#define RK3288_GRF_GPIO3D_E             0x01ec
+#define RK3288_GRF_GPIO4A_E             0x01f0
+#define RK3288_GRF_GPIO4B_E             0x01f4
+#define RK3288_GRF_GPIO4C_E             0x01f8
+#define RK3288_GRF_GPIO4D_E             0x01fc
+
+#define RK3288_GRF_GPIO5B_E             0x0204
+#define RK3288_GRF_GPIO5C_E             0x0208
+
+#define RK3288_GRF_GPIO6A_E             0x0210
+#define RK3288_GRF_GPIO6B_E             0x0214
+#define RK3288_GRF_GPIO6C_E             0x0218
+
+#define RK3288_GRF_GPIO7A_E             0x0220
+#define RK3288_GRF_GPIO7B_E             0x0224
+#define RK3288_GRF_GPIO7C_E             0x0228
+
+#define RK3288_GRF_GPIO8A_E             0x0230
+#define RK3288_GRF_GPIO8B_E             0x0234
+
+#define RK3288_GRF_GPIO_SMT             0x0240
+#define RK3288_GRF_SOC_CON0             0x0244
+#define RK3288_GRF_SOC_CON1             0x0248
+#define RK3288_GRF_SOC_CON2             0x024c
+#define RK3288_GRF_SOC_CON3             0x0250
+#define RK3288_GRF_SOC_CON4             0x0254
+#define RK3288_GRF_SOC_CON5             0x0258
+#define RK3288_GRF_SOC_CON6             0x025c
+#define RK3288_GRF_SOC_CON7             0x0260
+#define RK3288_GRF_SOC_CON8             0x0264
+#define RK3288_GRF_SOC_CON9             0x0268
+#define RK3288_GRF_SOC_CON10            0x026c
+#define RK3288_GRF_SOC_CON11            0x0270
+#define RK3288_GRF_SOC_CON12            0x0274
+#define RK3288_GRF_SOC_CON13            0x0278
+#define RK3288_GRF_SOC_CON14            0x027c
+#define RK3288_GRF_SOC_STATUS0          0x0280
+#define RK3288_GRF_SOC_STATUS1          0x0284
+#define RK3288_GRF_SOC_STATUS2          0x0288
+#define RK3288_GRF_SOC_STATUS3          0x028c
+#define RK3288_GRF_SOC_STATUS4          0x0290
+#define RK3288_GRF_SOC_STATUS5          0x0294
+#define RK3288_GRF_SOC_STATUS6          0x0298
+#define RK3288_GRF_SOC_STATUS7          0x029c
+#define RK3288_GRF_SOC_STATUS8          0x02a0
+#define RK3288_GRF_SOC_STATUS9          0x02a4
+#define RK3288_GRF_SOC_STATUS10         0x02a8
+#define RK3288_GRF_SOC_STATUS11         0x02ac
+#define RK3288_GRF_SOC_STATUS12         0x02b0
+#define RK3288_GRF_SOC_STATUS13         0x02b4
+#define RK3288_GRF_SOC_STATUS14         0x02b8
+#define RK3288_GRF_SOC_STATUS15         0x02bc
+#define RK3288_GRF_SOC_STATUS16         0x02c0
+#define RK3288_GRF_SOC_STATUS17         0x02c4
+#define RK3288_GRF_SOC_STATUS18         0x02c8
+#define RK3288_GRF_SOC_STATUS19         0x02cc
+#define RK3288_GRF_SOC_STATUS20         0x02d0
+#define RK3288_GRF_SOC_STATUS21         0x02d4
+
+#define RK3288_GRF_PERIDMAC_CON0        0x02e0
+#define RK3288_GRF_PERIDMAC_CON1        0x02e4
+#define RK3288_GRF_PERIDMAC_CON2        0x02e8
+#define RK3288_GRF_PERIDMAC_CON3        0x02ec
+#define RK3288_GRF_DDRC0_CON0           0x02f0
+#define RK3288_GRF_DDRC1_CON0           0x02f4
+#define RK3288_GRF_CPU_CON0             0x02f8
+#define RK3288_GRF_CPU_CON1             0x02fc
+#define RK3288_GRF_CPU_CON2             0x0300
+#define RK3288_GRF_CPU_CON3             0x0304
+#define RK3288_GRF_CPU_CON4             0x0308
+
+#define RK3288_GRF_CPU_STATUS0          0x0318
+
+#define RK3288_GRF_UOC0_CON0            0x0320
+#define RK3288_GRF_UOC0_CON1            0x0324
+#define RK3288_GRF_UOC0_CON2            0x0328
+#define RK3288_GRF_UOC0_CON3            0x032c
+#define RK3288_GRF_UOC0_CON4            0x0330
+#define RK3288_GRF_UOC1_CON0            0x0334
+#define RK3288_GRF_UOC1_CON1            0x0338
+#define RK3288_GRF_UOC1_CON2            0x033c
+#define RK3288_GRF_UOC1_CON3            0x0340
+#define RK3288_GRF_UOC1_CON4            0x0344
+#define RK3288_GRF_UOC2_CON0            0x0348
+#define RK3288_GRF_UOC2_CON1            0x034c
+#define RK3288_GRF_UOC2_CON2            0x0350
+#define RK3288_GRF_UOC2_CON3            0x0354
+#define RK3288_GRF_UOC3_CON0            0x0358
+#define RK3288_GRF_UOC3_CON1            0x035c
+#define RK3288_GRF_UOC4_CON0            0x0360
+#define RK3288_GRF_UOC4_CON1            0x0364
+#define RK3288_GRF_PVTM_CON0            0x0368
+#define RK3288_GRF_PVTM_CON1            0x036c
+#define RK3288_GRF_PVTM_CON2            0x0370
+#define RK3288_GRF_PVTM_STATUS0         0x0374
+#define RK3288_GRF_PVTM_STATUS1         0x0378
+#define RK3288_GRF_PVTM_STATUS2         0x037c
+#define RK3288_GRF_IO_VSEL              0x0380
+#define RK3288_GRF_SARADC_TESTBIT       0x0384
+#define RK3288_GRF_TSADC_TESTBIT_L      0x0388
+#define RK3288_GRF_TSADC_TESTBIT_H      0x038c
+#define RK3288_GRF_OS_REG0              0x0390
+#define RK3288_GRF_OS_REG1              0x0394
+#define RK3288_GRF_OS_REG2              0x0398
+#define RK3288_GRF_OS_REG3              0x039c
+
+#define RK3288_GRF_SOC_CON15            0x03a4
+#define RK3288_GRF_SOC_CON16            0x03a8
+
+#define RK3288_SGRF_SOC_CON0            0x0000
+#define RK3288_SGRF_SOC_CON1            0x0004
+#define RK3288_SGRF_SOC_CON2            0x0008
+#define RK3288_SGRF_SOC_CON3            0x000c
+#define RK3288_SGRF_SOC_CON4            0x0010
+#define RK3288_SGRF_SOC_CON5            0x0014
+
+#define RK3288_SGRF_BUSDMAC_CON0        0x0020
+#define RK3288_SGRF_BUSDMAC_CON1        0x0024
+
+#define RK3288_SGRF_CPU_CON0            0x0040
+#define RK3288_SGRF_CPU_CON1            0x0044
+#define RK3288_SGRF_CPU_CON2            0x0048
+
+#define RK3288_SGRF_SOC_CON6            0x0050
+#define RK3288_SGRF_SOC_CON7            0x0054
+#define RK3288_SGRF_SOC_CON8            0x0058
+#define RK3288_SGRF_SOC_CON9            0x005c
+#define RK3288_SGRF_SOC_CON10           0x0060
+#define RK3288_SGRF_SOC_CON11           0x0064
+#define RK3288_SGRF_SOC_CON12           0x0068
+#define RK3288_SGRF_SOC_CON13           0x006c
+#define RK3288_SGRF_SOC_CON14           0x0070
+#define RK3288_SGRF_SOC_CON15           0x0074
+#define RK3288_SGRF_SOC_CON16           0x0078
+#define RK3288_SGRF_SOC_CON17           0x007c
+#define RK3288_SGRF_SOC_CON18           0x0080
+#define RK3288_SGRF_SOC_CON19           0x0084
+#define RK3288_SGRF_SOC_CON20           0x0088
+#define RK3288_SGRF_SOC_CON21           0x008c
+
+#define RK3288_SGRF_SOC_STATUS0         0x0100
+#define RK3288_SGRF_SOC_STATUS1         0x0104
+
+#define RK3288_SGRF_FAST_BOOT_ADDR      0x0120
+
+
+#define RK3036_GRF_GPIO0A_IOMUX         0x000a8
+#define RK3036_GRF_GPIO0B_IOMUX         0x000ac
+#define RK3036_GRF_GPIO0C_IOMUX         0x000b0
+#define RK3036_GRF_GPIO0D_IOMUX         0x000b4
+#define RK3036_GRF_GPIO1A_IOMUX         0x000b8
+#define RK3036_GRF_GPIO1B_IOMUX         0x000bc
+#define RK3036_GRF_GPIO1C_IOMUX         0x000c0
+#define RK3036_GRF_GPIO1D_IOMUX         0x000c4
+#define RK3036_GRF_GPIO2A_IOMUX         0x000c8
+#define RK3036_GRF_GPIO2B_IOMUX         0x000cc
+#define RK3036_GRF_GPIO2C_IOMUX         0x000d0
+#define RK3036_GRF_GPIO2D_IOMUX         0x000d4
+#define RK3036_GRF_GPIO_DS              0x00100
+#define RK3036_GRF_GPIO0L_PULL          0x00118
+#define RK3036_GRF_GPIO0H_PULL          0x0011c
+#define RK3036_GRF_GPIO1L_PULL          0x00120
+#define RK3036_GRF_GPIO1H_PULL          0x00124
+
+#define RK3036_GRF_GPIO2L_PULL 0x00128
+#define RK3036_GRF_GPIO2H_PULL 0x0012c
+#define RK3036_GRF_SOC_CON0 0x00140
+#define RK3036_GRF_SOC_CON1 0x00144
+#define RK3036_GRF_SOC_CON2 0x00148
+#define RK3036_GRF_SOC_STATUS0 0x0014c
+#define RK3036_GRF_SOC_CON3 0x00154
+#define RK3036_GRF_DMAC_CON0 0x0015c
+#define RK3036_GRF_DMAC_CON1 0x00160
+#define RK3036_GRF_DMAC_CON2 0x00164
+#define RK3036_GRF_UOC0_CON5 0x0017c
+#define RK3036_GRF_UOC1_CON4 0x00190
+#define RK3036_GRF_UOC1_CON5 0x00194
+#define RK3036_GRF_DDRC_STAT 0x0019c
+#define RK3036_GRF_UOC_CON6 0x001a0
+#define RK3036_GRF_SOC_STATUS1 0x001a4
+#define RK3036_GRF_CPU_CON0 0x001a8
+#define RK3036_GRF_CPU_CON1 0x001ac
+#define RK3036_GRF_CPU_CON2 0x001b0
+#define RK3036_GRF_CPU_CON3 0x001b4
+#define RK3036_GRF_CPU_STATUS0 0x001c0
+#define RK3036_GRF_CPU_STATUS1 0x001c4
+#define RK3036_GRF_OS_REG0 0x001c8
+#define RK3036_GRF_OS_REG1 0x001cc
+#define RK3036_GRF_OS_REG2 0x001d0
+#define RK3036_GRF_OS_REG3 0x001d4
+#define RK3036_GRF_OS_REG4 0x001d8
+#define RK3036_GRF_OS_REG5 0x001dc
+#define RK3036_GRF_OS_REG6 0x001e0
+#define RK3036_GRF_OS_REG7 0x001e4
+#define RK3036_GRF_DLL_CON0 0x00200
+#define RK3036_GRF_DLL_CON1 0x00204
+#define RK3036_GRF_DLL_CON2 0x00208
+#define RK3036_GRF_DLL_CON3 0x0020c
+#define RK3036_GRF_DLL_STATUS0 0x00210
+#define RK3036_GRF_DLL_STATUS1 0x00214
+
+#define RK3036_GRF_DLL_STATUS2 0x00218
+#define RK3036_GRF_DLL_STATUS3 0x0021c
+#define RK3036_GRF_DFI_WRNUM 0x00220
+#define RK3036_GRF_DFI_RDNUM 0x00224
+#define RK3036_GRF_DFI_ACTNUM 0x00228
+#define RK3036_GRF_DFI_TIMERVAL 0x0022c
+#define RK3036_GRF_NIF_FIFO0 0x00230
+#define RK3036_GRF_NIF_FIFO1 0x00234
+#define RK3036_GRF_NIF_FIFO2 0x00238
+#define RK3036_GRF_NIF_FIFO3 0x0023c
+#define RK3036_GRF_USBPHY0_CON0 0x00280
+#define RK3036_GRF_USBPHY0_CON1 0x00284
+#define RK3036_GRF_USBPHY0_CON2 0x00288
+#define RK3036_GRF_USBPHY0_CON3 0x0028c
+#define RK3036_GRF_USBPHY0_CON4 0x00290
+#define RK3036_GRF_USBPHY0_CON5 0x00294
+#define RK3036_GRF_USBPHY0_CON6 0x00298
+#define RK3036_GRF_USBPHY0_CON7 0x0029c
+#define RK3036_GRF_USBPHY1_CON0 0x002a0
+#define RK3036_GRF_USBPHY1_CON1 0x002a4
+#define RK3036_GRF_USBPHY1_CON2 0x002a8
+#define RK3036_GRF_USBPHY1_CON3 0x002ac
+#define RK3036_GRF_USBPHY1_CON4 0x002b0
+#define RK3036_GRF_USBPHY1_CON5 0x002b4
+#define RK3036_GRF_USBPHY1_CON6 0x002b8
+
+#define RK3036_GRF_USBPHY1_CON7 0x002bc
+#define RK3036_GRF_CHIP_TAG 0x00300
+#define RK3036_GRF_SDMMC_DET_CNT 0x00304
+
+#define RK312X_GRF_GPIO0A_IOMUX         0x000a8
+#define RK312X_GRF_GPIO0B_IOMUX         0x000ac
+#define RK312X_GRF_GPIO0C_IOMUX         0x000b0
+#define RK312X_GRF_GPIO0D_IOMUX         0x000b4
+#define RK312X_GRF_GPIO1A_IOMUX         0x000b8
+#define RK312X_GRF_GPIO1B_IOMUX         0x000bc
+#define RK312X_GRF_GPIO1C_IOMUX         0x000c0
+#define RK312X_GRF_GPIO1D_IOMUX         0x000c4
+#define RK312X_GRF_GPIO2A_IOMUX         0x000c8
+#define RK312X_GRF_GPIO2B_IOMUX         0x000cc
+#define RK312X_GRF_GPIO2C_IOMUX         0x000d0
+#define RK312X_GRF_GPIO2D_IOMUX         0x000d4
+#define RK312X_GRF_GPIO3A_IOMUX         0x000d8
+#define RK312X_GRF_GPIO3B_IOMUX         0x000dc
+#define RK312X_GRF_GPIO3C_IOMUX         0x000e0
+#define RK312X_GRF_GPIO3D_IOMUX         0x000e4
+#define RK312X_GRF_CIF_IOMUX		0x000ec
+#define RK312X_GRF_CIF_IOMUX1 		0x000f0
+#define RK312X_GRF_GPIO_DS              0x00100
+#define RK312X_GRF_GPIO0L_PULL          0x00118
+#define RK312X_GRF_GPIO0H_PULL          0x0011c
+#define RK312X_GRF_GPIO1L_PULL          0x00120
+#define RK312X_GRF_GPIO1H_PULL          0x00124
+#define RK312X_GRF_GPIO2L_PULL          0x00128
+#define RK312X_GRF_GPIO2H_PULL          0x0012c
+#define RK312X_GRF_GPIO3L_PULL          0x00130
+#define RK312X_GRF_GPIO3H_PULL          0x00134
+#define RK312X_GRF_ACODEC_CON		0x0013c
+
+#define RK312X_GRF_SOC_CON0 0x00140
+#define RK312X_GRF_SOC_CON1 0x00144
+#define RK312X_GRF_SOC_CON2 0x00148
+#define RK312X_GRF_SOC_STATUS0 0x0014c
+#define RK312X_GRF_LVDS_CON0 0x00150
+#define RK312X_GRF_SOC_CON3 0x00154
+#define RK312X_GRF_DMAC_CON0 0x0015c
+#define RK312X_GRF_DMAC_CON1 0x00160
+#define RK312X_GRF_DMAC_CON2 0x00164
+#define RK312X_GRF_MAC_CON0 0x00168
+#define RK312X_GRF_MAC_CON1 0x0016c
+#define RK312X_GRF_TVE_CON 0x00170
+#define RK312X_GRF_UOC0_CON0 0x0017c
+#define RK312X_GRF_UOC1_CON1 0x00184
+#define RK312X_GRF_UOC1_CON2 0x00188
+#define RK312X_GRF_UOC1_CON3 0x0018c
+#define RK312X_GRF_UOC1_CON4 0x00190
+#define RK312X_GRF_UOC1_CON5 0x00194
+#define RK312X_GRF_DDRC_STAT 0x0019c
+#define RK312X_GRF_SOC_STATUS1 0x001a4
+#define RK312X_GRF_CPU_CON0 0x001a8
+#define RK312X_GRF_CPU_CON1 0x001ac
+#define RK312X_GRF_CPU_CON2 0x001b0
+#define RK312X_GRF_CPU_CON3 0x001b4
+#define RK312X_GRF_CPU_STATUS0 0x001c0
+#define RK312X_GRF_CPU_STATUS1 0x001c4
+#define RK312X_GRF_OS_REG0 0x001c8
+#define RK312X_GRF_OS_REG1 0x001cc
+#define RK312X_GRF_OS_REG2 0x001d0
+#define RK312X_GRF_OS_REG3 0x001d4
+#define RK312X_GRF_OS_REG4 0x001d8
+#define RK312X_GRF_OS_REG5 0x001dc
+#define RK312X_GRF_OS_REG6 0x001e0
+#define RK312X_GRF_OS_REG7 0x001e4
+#define RK312X_GRF_PVTM_CON0 0x00200
+#define RK312X_GRF_PVTM_CON1 0x00204
+#define RK312X_GRF_PVTM_CON2 0x00208
+#define RK312X_GRF_PVTM_CON3 0x0020c
+#define RK312X_GRF_PVTM_STATUS0 0x00210
+#define RK312X_GRF_PVTM_STATUS1 0x00214
+#define RK312X_GRF_PVTM_STATUS2 0x00218
+#define RK312X_GRF_PVTM_STATUS3 0x0021c
+#define RK312X_GRF_DFI_WRNUM 0x00220
+#define RK312X_GRF_DFI_RDNUM 0x00224
+#define RK312X_GRF_DFI_ACTNUM 0x00228
+#define RK312X_GRF_DFI_TIMERVAL 0x0022c
+#define RK312X_GRF_NIF_FIFO0 0x00230
+#define RK312X_GRF_NIF_FIFO1 0x00234
+#define RK312X_GRF_NIF_FIFO2 0x00238
+#define RK312X_GRF_NIF_FIFO3 0x0023c
+#define RK312X_GRF_USBPHY0_CON0 0x00280
+#define RK312X_GRF_USBPHY0_CON1 0x00284
+#define RK312X_GRF_USBPHY0_CON2 0x00288
+#define RK312X_GRF_USBPHY0_CON3 0x0028c
+#define RK312X_GRF_USBPHY0_CON4 0x00290
+#define RK312X_GRF_USBPHY0_CON5 0x00294
+#define RK312X_GRF_USBPHY0_CON6 0x00298
+#define RK312X_GRF_USBPHY0_CON7 0x0029c
+#define RK312X_GRF_USBPHY1_CON0 0x002a0
+#define RK312X_GRF_USBPHY1_CON1 0x002a4
+#define RK312X_GRF_USBPHY1_CON2 0x002a8
+#define RK312X_GRF_USBPHY1_CON3 0x002ac
+#define RK312X_GRF_USBPHY1_CON4 0x002b0
+#define RK312X_GRF_USBPHY1_CON5 0x002b4
+#define RK312X_GRF_USBPHY1_CON6 0x002b8
+#define RK312X_GRF_USBPHY1_CON7 0x002bc
+#define RK312X_GRF_UOC_STATUS0 0x002c0
+#define RK312X_GRF_CHIP_TAG 0x00300
+#define RK312X_GRF_SDMMC_DET_CNT 0x00304
+#define RK312X_GRF_EFUSE_PRG_EN 0x0037c
+
+#define RK3228_GRF_GPIO0A_IOMUX		0x0000
+#define RK3228_GRF_GPIO0B_IOMUX		0x0004
+#define RK3228_GRF_GPIO0C_IOMUX		0x0008
+#define RK3228_GRF_GPIO0D_IOMUX		0x000c
+#define RK3228_GRF_GPIO1A_IOMUX		0x0010
+#define RK3228_GRF_GPIO1B_IOMUX		0x0014
+#define RK3228_GRF_GPIO1C_IOMUX		0x0018
+#define RK3228_GRF_GPIO1D_IOMUX		0x001c
+#define RK3228_GRF_GPIO2A_IOMUX		0x0020
+#define RK3228_GRF_GPIO2B_IOMUX		0x0024
+#define RK3228_GRF_GPIO2C_IOMUX		0x0028
+#define RK3228_GRF_GPIO2D_IOMUX		0x002c
+#define RK3228_GRF_GPIO3A_IOMUX		0x0030
+#define RK3228_GRF_GPIO3B_IOMUX		0x0034
+#define RK3228_GRF_GPIO3C_IOMUX		0x0038
+#define RK3228_GRF_GPIO3D_IOMUX		0x003c
+#define RK3228_GRF_COM_IOMUX		0x0050
+#define RK3228_GRF_GPIO0A_P		0x0100
+#define RK3228_GRF_GPIO0B_P		0x0104
+#define RK3228_GRF_GPIO0C_P		0x0108
+#define RK3228_GRF_GPIO0D_P		0x010c
+#define RK3228_GRF_GPIO1A_P		0x0110
+#define RK3228_GRF_GPIO1B_P		0x0114
+#define RK3228_GRF_GPIO1C_P		0x0118
+#define RK3228_GRF_GPIO1D_P		0x011c
+#define RK3228_GRF_GPIO2A_P		0x0120
+#define RK3228_GRF_GPIO2B_P		0x0124
+#define RK3228_GRF_GPIO2C_P		0x0128
+#define RK3228_GRF_GPIO2D_P		0x012c
+#define RK3228_GRF_GPIO3A_P		0x0130
+#define RK3228_GRF_GPIO3B_P		0x0134
+#define RK3228_GRF_GPIO3C_P		0x0138
+#define RK3228_GRF_GPIO3D_P		0x013c
+#define RK3228_GRF_GPIO0A_E		0x0200
+#define RK3228_GRF_GPIO0B_E		0x0204
+#define RK3228_GRF_GPIO0C_E		0x0208
+#define RK3228_GRF_GPIO0D_E		0x020c
+#define RK3228_GRF_GPIO1A_E		0x0210
+#define RK3228_GRF_GPIO1B_E		0x0214
+#define RK3228_GRF_GPIO1C_E		0x0218
+#define RK3228_GRF_GPIO1D_E		0x021c
+#define RK3228_GRF_GPIO2A_E		0x0220
+#define RK3228_GRF_GPIO2B_E		0x0224
+#define RK3228_GRF_GPIO2C_E		0x0228
+#define RK3228_GRF_GPIO2D_E		0x022c
+#define RK3228_GRF_GPIO3A_E		0x0230
+#define RK3228_GRF_GPIO3B_E		0x0234
+#define RK3228_GRF_GPIO3C_E		0x0238
+#define RK3228_GRF_GPIO3D_E		0x023c
+#define RK3228_GRF_GPIO0L_SR		0x0300
+#define RK3228_GRF_GPIO0H_SR		0x0304
+#define RK3228_GRF_GPIO1L_SR		0x0308
+#define RK3228_GRF_GPIO1H_SR		0x030c
+#define RK3228_GRF_GPIO2L_SR		0x0310
+#define RK3228_GRF_GPIO2H_SR		0x0314
+#define RK3228_GRF_GPIO3L_SR		0x0318
+#define RK3228_GRF_GPIO3H_SR		0x031c
+#define RK3228_GRF_GPIO0L_SMT		0x0380
+#define RK3228_GRF_GPIO0H_SMT		0x0384
+#define RK3228_GRF_GPIO1L_SMT		0x0388
+#define RK3228_GRF_GPIO1H_SMT		0x038c
+#define RK3228_GRF_GPIO2L_SMT		0x0390
+#define RK3228_GRF_GPIO2H_SMT		0x0394
+#define RK3228_GRF_GPIO3L_SMT		0x0398
+#define RK3228_GRF_GPIO3H_SMT		0x039c
+#define RK3228_GRF_SOC_CON0		0x0400
+#define RK3228_GRF_SOC_CON1		0x0404
+#define RK3228_GRF_SOC_CON2		0x0408
+#define RK3228_GRF_SOC_CON3		0x040c
+#define RK3228_GRF_SOC_CON4		0x0410
+#define RK3228_GRF_SOC_CON5		0x0414
+#define RK3228_GRF_SOC_CON6		0x0418
+#define RK3228_GRF_SOC_STATUS0		0x0480
+#define RK3228_GRF_SOC_STATUS1		0x0484
+#define RK3228_GRF_SOC_STATUS2		0x0488
+#define RK3228_GRF_CHIP_ID		0x048c
+#define RK3228_GRF_CPU_CON0		0x0500
+#define RK3228_GRF_CPU_CON1		0x0504
+#define RK3228_GRF_CPU_CON2		0x0508
+#define RK3228_GRF_CPU_CON3		0x050c
+#define RK3228_GRF_CPU_STATUS0		0x0520
+#define RK3228_GRF_CPU_STATUS1		0x0524
+#define RK3228_GRF_OS_REG0		0x05c8
+#define RK3228_GRF_OS_REG1		0x05cc
+#define RK3228_GRF_OS_REG2		0x05d0
+#define RK3228_GRF_OS_REG3		0x05d4
+#define RK3228_GRF_OS_REG4		0x05d8
+#define RK3228_GRF_OS_REG5		0x05dc
+#define RK3228_GRF_OS_REG6		0x05e0
+#define RK3228_GRF_OS_REG7		0x05e4
+#define RK3228_GRF_DDRC_STAT		0x0604
+#define RK3228_GRF_SIG_DETECT_CON	0x0680
+#define RK3228_GRF_SIG_DETECT_CON1	0x0684
+#define RK3228_GRF_SIG_DETECT_STATUS	0x0690
+#define RK3228_GRF_SIG_DETECT_STATUS1	0x0694
+#define RK3228_GRF_SIG_DETECT_CLR	0x06a0
+#define RK3228_GRF_SIG_DETECT_CLR1	0x06a4
+#define RK3228_GRF_EMMC_DET		0x06b0
+#define RK3228_GRF_HOST0_CON0		0x0700
+#define RK3228_GRF_HOST0_CON1		0x0704
+#define RK3228_GRF_HOST0_CON2		0x0708
+#define RK3228_GRF_HOST1_CON0		0x0710
+#define RK3228_GRF_HOST1_CON1		0x0714
+#define RK3228_GRF_HOST1_CON2		0x0718
+#define RK3228_GRF_HOST2_CON0		0x0720
+#define RK3228_GRF_HOST2_CON1		0x0724
+#define RK3228_GRF_HOST2_CON2		0x0728
+#define RK3228_GRF_USBPHY0_CON0		0x0760
+#define RK3228_GRF_USBPHY0_CON1		0x0764
+#define RK3228_GRF_USBPHY0_CON2		0x0768
+#define RK3228_GRF_USBPHY0_CON3		0x076c
+#define RK3228_GRF_USBPHY0_CON4		0x0770
+#define RK3228_GRF_USBPHY0_CON5		0x0774
+#define RK3228_GRF_USBPHY0_CON6		0x0778
+#define RK3228_GRF_USBPHY0_CON7		0x077c
+#define RK3228_GRF_USBPHY0_CON8		0x0780
+#define RK3228_GRF_USBPHY0_CON9		0x0784
+#define RK3228_GRF_USBPHY0_CON10	0x0788
+#define RK3228_GRF_USBPHY0_CON11	0x078c
+#define RK3228_GRF_USBPHY0_CON12	0x0790
+#define RK3228_GRF_USBPHY0_CON13	0x0794
+#define RK3228_GRF_USBPHY0_CON14	0x0798
+#define RK3228_GRF_USBPHY0_CON15	0x079c
+#define RK3228_GRF_USBPHY0_CON16	0x07a0
+#define RK3228_GRF_USBPHY0_CON17	0x07a4
+#define RK3228_GRF_USBPHY0_CON18	0x07a8
+#define RK3228_GRF_USBPHY0_CON19	0x07ac
+#define RK3228_GRF_USBPHY0_CON20	0x07b0
+#define RK3228_GRF_USBPHY0_CON21	0x07b4
+#define RK3228_GRF_USBPHY0_CON22	0x07b8
+#define RK3228_GRF_USBPHY0_CON23	0x07bc
+#define RK3228_GRF_USBPHY0_CON24	0x07c0
+#define RK3228_GRF_USBPHY0_CON25	0x07c4
+#define RK3228_GRF_USBPHY0_CON26	0x07c8
+#define RK3228_GRF_USBPHY1_CON0		0x0800
+#define RK3228_GRF_USBPHY1_CON1		0x0804
+#define RK3228_GRF_USBPHY1_CON2		0x0808
+#define RK3228_GRF_USBPHY1_CON3		0x080c
+#define RK3228_GRF_USBPHY1_CON4		0x0810
+#define RK3228_GRF_USBPHY1_CON5		0x0814
+#define RK3228_GRF_USBPHY1_CON6		0x0818
+#define RK3228_GRF_USBPHY1_CON7		0x081c
+#define RK3228_GRF_USBPHY1_CON8		0x0820
+#define RK3228_GRF_USBPHY1_CON9		0x0824
+#define RK3228_GRF_USBPHY1_CON10	0x0828
+#define RK3228_GRF_USBPHY1_CON11	0x082c
+#define RK3228_GRF_USBPHY1_CON12	0x0830
+#define RK3228_GRF_USBPHY1_CON13	0x0834
+#define RK3228_GRF_USBPHY1_CON14	0x0838
+#define RK3228_GRF_USBPHY1_CON15	0x083c
+#define RK3228_GRF_USBPHY1_CON16	0x0840
+#define RK3228_GRF_USBPHY1_CON17	0x0844
+#define RK3228_GRF_USBPHY1_CON18	0x0848
+#define RK3228_GRF_USBPHY1_CON19	0x084c
+#define RK3228_GRF_USBPHY1_CON20	0x0850
+#define RK3228_GRF_USBPHY1_CON21	0x0854
+#define RK3228_GRF_USBPHY1_CON22	0x0858
+#define RK3228_GRF_USBPHY1_CON23	0x085c
+#define RK3228_GRF_USBPHY1_CON24	0x0860
+#define RK3228_GRF_USBPHY1_CON25	0x0864
+#define RK3228_GRF_USBPHY1_CON26	0x0868
+#define RK3228_GRF_OTG_CON0		0x0880
+#define RK3228_GRF_UOC_CON0		0x0884
+#define RK3228_GRF_MAC_CON0		0x0900
+#define RK3228_GRF_MAC_CON1		0x0904
+#define RK3228_GRF_MACPHY_CON0		0x0b00
+#define RK3228_GRF_MACPHY_CON1		0x0b04
+#define RK3228_GRF_MACPHY_CON2		0x0b08
+#define RK3228_GRF_MACPHY_CON3		0x0b0c
+#define RK3228_GRF_MACPHY_STATUS	0x0b10
+
+#endif
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index c67667bb970f..881a6ccb10cc 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -104,6 +104,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_PCM5102A
 	select SND_SOC_PCM512x_I2C if I2C
 	select SND_SOC_PCM512x_SPI if SPI_MASTER
+	select SND_SOC_RK3308
 	select SND_SOC_RT286 if I2C
 	select SND_SOC_RT298 if I2C
 	select SND_SOC_RT5514 if I2C
@@ -640,6 +641,10 @@ config SND_SOC_PCM512x_SPI
 	select SND_SOC_PCM512x
 	select REGMAP_SPI
 
+config SND_SOC_RK3308
+	select REGMAP_MMIO
+	tristate "Rockchip RK3308 CODEC"
+
 config SND_SOC_RL6231
 	tristate
 	default y if SND_SOC_RT5514=y
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 958cd4912fbc..b8a0fa2eb6ef 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -101,6 +101,7 @@ snd-soc-pcm5102a-objs := pcm5102a.o
 snd-soc-pcm512x-objs := pcm512x.o
 snd-soc-pcm512x-i2c-objs := pcm512x-i2c.o
 snd-soc-pcm512x-spi-objs := pcm512x-spi.o
+snd-soc-rk3308-objs := rk3308_codec.o
 snd-soc-rl6231-objs := rl6231.o
 snd-soc-rl6347a-objs := rl6347a.o
 snd-soc-rt286-objs := rt286.o
@@ -325,6 +326,7 @@ obj-$(CONFIG_SND_SOC_PCM5102A)	+= snd-soc-pcm5102a.o
 obj-$(CONFIG_SND_SOC_PCM512x)	+= snd-soc-pcm512x.o
 obj-$(CONFIG_SND_SOC_PCM512x_I2C)	+= snd-soc-pcm512x-i2c.o
 obj-$(CONFIG_SND_SOC_PCM512x_SPI)	+= snd-soc-pcm512x-spi.o
+obj-$(CONFIG_SND_SOC_RK3308)	+= snd-soc-rk3308.o
 obj-$(CONFIG_SND_SOC_RL6231)	+= snd-soc-rl6231.o
 obj-$(CONFIG_SND_SOC_RL6347A)	+= snd-soc-rl6347a.o
 obj-$(CONFIG_SND_SOC_RT286)	+= snd-soc-rt286.o
diff --git a/sound/soc/codecs/rk3308_codec.c b/sound/soc/codecs/rk3308_codec.c
new file mode 100644
index 000000000000..54171b60db92
--- /dev/null
+++ b/sound/soc/codecs/rk3308_codec.c
@@ -0,0 +1,2868 @@
+/*
+ * rk3308_codec.c -- RK3308 ALSA Soc Audio Driver
+ *
+ * Copyright (c) 2018, Fuzhou Rockchip Electronics Co., Ltd All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/rockchip/grf.h>
+#include <linux/version.h>
+#include <sound/core.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/initval.h>
+#include <sound/jack.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/simple_card.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#include "rk3308_codec.h"
+#include "rk3308_codec_provider.h"
+
+#if defined(CONFIG_DEBUG_FS)
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#endif
+
+#define CODEC_DRV_NAME			"rk3308-acodec"
+
+#define ADC_LR_GROUP_MAX		4
+#define DEBUG_POP_ALWAYS		0
+#define ENABLE_AGC			0
+#define HPDET_POLL_MS			2000
+
+enum {
+	ADC_GRP0_MICIN = 0,
+	ADC_GRP0_LINEIN
+};
+
+enum {
+	DAC_LINEOUT = 0,
+	DAC_HPOUT = 1,
+	DAC_LINEOUT_HPOUT = 11,
+};
+
+enum {
+	PATH_IDLE = 0,
+	PATH_BUSY,
+};
+
+struct rk3308_codec_priv {
+	const struct device *plat_dev;
+	struct device dev;
+	struct reset_control *reset;
+	struct regmap *regmap;
+	struct clk *pclk;
+	struct clk *mclk_rx;
+	struct clk *mclk_tx;
+	struct gpio_desc *hp_ctl_gpio;
+	struct gpio_desc *spk_ctl_gpio;
+	struct snd_soc_jack *hpdet_jack;
+	int irq;
+	/*
+	 * To select ADCs for groups:
+	 *
+	 * grp 0 -- select ADC1 / ADC2
+	 * grp 1 -- select ADC3 / ADC4
+	 * grp 2 -- select ADC5 / ADC6
+	 * grp 3 -- select ADC7 / ADC8
+	 */
+	int adc_cur_grp;
+	int adc_grp0_using_linein;
+	int adc_zerocross;
+	/* 0: line out, 1: hp out, 11: lineout and hpout */
+	int dac_output;
+	int dac_path_state;
+
+	bool hp_plugged;
+	struct delayed_work hpdet_work;
+
+#if defined(CONFIG_DEBUG_FS)
+	struct dentry *dbg_codec;
+#endif
+};
+
+static const DECLARE_TLV_DB_SCALE(rk3308_codec_alc_agc_grp_gain_tlv,
+				  -1800, 150, 2850);
+static const DECLARE_TLV_DB_SCALE(rk3308_codec_alc_agc_grp_max_gain_tlv,
+				  -1350, 600, 2850);
+static const DECLARE_TLV_DB_SCALE(rk3308_codec_alc_agc_grp_min_gain_tlv,
+				  -1800, 600, 2400);
+static const DECLARE_TLV_DB_SCALE(rk3308_codec_adc_alc_gain_tlv,
+				  -1800, 150, 2850);
+static const DECLARE_TLV_DB_SCALE(rk3308_codec_dac_lineout_gain_tlv,
+				  -600, 150, 0);
+static const DECLARE_TLV_DB_SCALE(rk3308_codec_dac_hpout_gain_tlv,
+				  -3900, 150, 600);
+static const DECLARE_TLV_DB_SCALE(rk3308_codec_dac_hpmix_gain_tlv,
+				  -600, 600, 0);
+static const DECLARE_TLV_DB_RANGE(rk3308_codec_adc_1_2_mic_gain_tlv,
+	0, 0, TLV_DB_MINMAX_ITEM(0, 0),
+	3, 3, TLV_DB_MINMAX_ITEM(2000, 2000),
+);
+static const DECLARE_TLV_DB_RANGE(rk3308_codec_adc_3_8_mic_gain_tlv,
+	0, 0, TLV_DB_MINMAX_ITEM(0, 0),
+	1, 1, TLV_DB_MINMAX_ITEM(660, 660),
+	2, 2, TLV_DB_MINMAX_ITEM(1300, 1300),
+	3, 3, TLV_DB_MINMAX_ITEM(2000, 2000),
+);
+
+static const struct snd_kcontrol_new rk3308_codec_dapm_controls[] = {
+	/* ALC AGC Group */
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 0 Left Volume",
+			     RK3308_ALC_L_DIG_CON03(0),
+			     RK3308_AGC_PGA_GAIN_SFT,
+			     RK3308_AGC_PGA_GAIN_MIN,
+			     RK3308_AGC_PGA_GAIN_MAX,
+			     0, rk3308_codec_alc_agc_grp_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 0 Right Volume",
+			     RK3308_ALC_R_DIG_CON03(0),
+			     RK3308_AGC_PGA_GAIN_SFT,
+			     RK3308_AGC_PGA_GAIN_MIN,
+			     RK3308_AGC_PGA_GAIN_MAX,
+			     0, rk3308_codec_alc_agc_grp_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 1 Left Volume",
+			     RK3308_ALC_L_DIG_CON03(1),
+			     RK3308_AGC_PGA_GAIN_SFT,
+			     RK3308_AGC_PGA_GAIN_MIN,
+			     RK3308_AGC_PGA_GAIN_MAX,
+			     0, rk3308_codec_alc_agc_grp_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 1 Right Volume",
+			     RK3308_ALC_R_DIG_CON03(1),
+			     RK3308_AGC_PGA_GAIN_SFT,
+			     RK3308_AGC_PGA_GAIN_MIN,
+			     RK3308_AGC_PGA_GAIN_MAX,
+			     0, rk3308_codec_alc_agc_grp_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 2 Left Volume",
+			     RK3308_ALC_L_DIG_CON03(2),
+			     RK3308_AGC_PGA_GAIN_SFT,
+			     RK3308_AGC_PGA_GAIN_MIN,
+			     RK3308_AGC_PGA_GAIN_MAX,
+			     0, rk3308_codec_alc_agc_grp_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 2 Right Volume",
+			     RK3308_ALC_R_DIG_CON03(2),
+			     RK3308_AGC_PGA_GAIN_SFT,
+			     RK3308_AGC_PGA_GAIN_MIN,
+			     RK3308_AGC_PGA_GAIN_MAX,
+			     0, rk3308_codec_alc_agc_grp_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 3 Left Volume",
+			     RK3308_ALC_L_DIG_CON03(3),
+			     RK3308_AGC_PGA_GAIN_SFT,
+			     RK3308_AGC_PGA_GAIN_MIN,
+			     RK3308_AGC_PGA_GAIN_MAX,
+			     0, rk3308_codec_alc_agc_grp_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 3 Right Volume",
+			     RK3308_ALC_R_DIG_CON03(3),
+			     RK3308_AGC_PGA_GAIN_SFT,
+			     RK3308_AGC_PGA_GAIN_MIN,
+			     RK3308_AGC_PGA_GAIN_MAX,
+			     0, rk3308_codec_alc_agc_grp_gain_tlv),
+
+	/* ALC AGC MAX */
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 0 Left Max Volume",
+			     RK3308_ALC_L_DIG_CON09(0),
+			     RK3308_AGC_MAX_GAIN_PGA_SFT,
+			     RK3308_AGC_MAX_GAIN_PGA_MIN,
+			     RK3308_AGC_MAX_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_max_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 0 Right Max Volume",
+			     RK3308_ALC_R_DIG_CON09(0),
+			     RK3308_AGC_MAX_GAIN_PGA_SFT,
+			     RK3308_AGC_MAX_GAIN_PGA_MIN,
+			     RK3308_AGC_MAX_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_max_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 1 Left Max Volume",
+			     RK3308_ALC_L_DIG_CON09(1),
+			     RK3308_AGC_MAX_GAIN_PGA_SFT,
+			     RK3308_AGC_MAX_GAIN_PGA_MIN,
+			     RK3308_AGC_MAX_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_max_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 1 Right Max Volume",
+			     RK3308_ALC_R_DIG_CON09(1),
+			     RK3308_AGC_MAX_GAIN_PGA_SFT,
+			     RK3308_AGC_MAX_GAIN_PGA_MIN,
+			     RK3308_AGC_MAX_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_max_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 2 Left Max Volume",
+			     RK3308_ALC_L_DIG_CON09(2),
+			     RK3308_AGC_MAX_GAIN_PGA_SFT,
+			     RK3308_AGC_MAX_GAIN_PGA_MIN,
+			     RK3308_AGC_MAX_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_max_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 2 Right Max Volume",
+			     RK3308_ALC_R_DIG_CON09(2),
+			     RK3308_AGC_MAX_GAIN_PGA_SFT,
+			     RK3308_AGC_MAX_GAIN_PGA_MIN,
+			     RK3308_AGC_MAX_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_max_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 3 Left Max Volume",
+			     RK3308_ALC_L_DIG_CON09(3),
+			     RK3308_AGC_MAX_GAIN_PGA_SFT,
+			     RK3308_AGC_MAX_GAIN_PGA_MIN,
+			     RK3308_AGC_MAX_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_max_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 3 Right Max Volume",
+			     RK3308_ALC_R_DIG_CON09(3),
+			     RK3308_AGC_MAX_GAIN_PGA_SFT,
+			     RK3308_AGC_MAX_GAIN_PGA_MIN,
+			     RK3308_AGC_MAX_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_max_gain_tlv),
+
+	/* ALC AGC MIN */
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 0 Left Min Volume",
+			     RK3308_ALC_L_DIG_CON09(0),
+			     RK3308_AGC_MIN_GAIN_PGA_SFT,
+			     RK3308_AGC_MIN_GAIN_PGA_MIN,
+			     RK3308_AGC_MIN_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_min_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 0 Right Min Volume",
+			     RK3308_ALC_R_DIG_CON09(0),
+			     RK3308_AGC_MIN_GAIN_PGA_SFT,
+			     RK3308_AGC_MIN_GAIN_PGA_MIN,
+			     RK3308_AGC_MIN_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_min_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 1 Left Min Volume",
+			     RK3308_ALC_L_DIG_CON09(1),
+			     RK3308_AGC_MIN_GAIN_PGA_SFT,
+			     RK3308_AGC_MIN_GAIN_PGA_MIN,
+			     RK3308_AGC_MIN_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_min_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 1 Right Min Volume",
+			     RK3308_ALC_R_DIG_CON09(1),
+			     RK3308_AGC_MIN_GAIN_PGA_SFT,
+			     RK3308_AGC_MIN_GAIN_PGA_MIN,
+			     RK3308_AGC_MIN_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_min_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 2 Left Min Volume",
+			     RK3308_ALC_L_DIG_CON09(2),
+			     RK3308_AGC_MIN_GAIN_PGA_SFT,
+			     RK3308_AGC_MIN_GAIN_PGA_MIN,
+			     RK3308_AGC_MIN_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_min_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 2 Right Min Volume",
+			     RK3308_ALC_R_DIG_CON09(2),
+			     RK3308_AGC_MIN_GAIN_PGA_SFT,
+			     RK3308_AGC_MIN_GAIN_PGA_MIN,
+			     RK3308_AGC_MIN_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_min_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 3 Left Min Volume",
+			     RK3308_ALC_L_DIG_CON09(3),
+			     RK3308_AGC_MIN_GAIN_PGA_SFT,
+			     RK3308_AGC_MIN_GAIN_PGA_MIN,
+			     RK3308_AGC_MIN_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_min_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 3 Right Min Volume",
+			     RK3308_ALC_R_DIG_CON09(3),
+			     RK3308_AGC_MIN_GAIN_PGA_SFT,
+			     RK3308_AGC_MIN_GAIN_PGA_MIN,
+			     RK3308_AGC_MIN_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_min_gain_tlv),
+
+	/* ADC MIC */
+	SOC_SINGLE_RANGE_TLV("ADC MIC Group 0 Left Volume",
+			     RK3308_ADC_ANA_CON01(0),
+			     RK3308_ADC_CH1_MIC_GAIN_SFT,
+			     RK3308_ADC_CH1_MIC_GAIN_MIN,
+			     RK3308_ADC_CH1_MIC_GAIN_MAX,
+			     0, rk3308_codec_adc_1_2_mic_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC MIC Group 0 Right Volume",
+			     RK3308_ADC_ANA_CON01(0),
+			     RK3308_ADC_CH2_MIC_GAIN_SFT,
+			     RK3308_ADC_CH2_MIC_GAIN_MIN,
+			     RK3308_ADC_CH2_MIC_GAIN_MAX,
+			     0, rk3308_codec_adc_1_2_mic_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC MIC Group 1 Left Volume",
+			     RK3308_ADC_ANA_CON01(1),
+			     RK3308_ADC_CH1_MIC_GAIN_SFT,
+			     RK3308_ADC_CH1_MIC_GAIN_MIN,
+			     RK3308_ADC_CH1_MIC_GAIN_MAX,
+			     0, rk3308_codec_adc_3_8_mic_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC MIC Group 1 Right Volume",
+			     RK3308_ADC_ANA_CON01(1),
+			     RK3308_ADC_CH2_MIC_GAIN_SFT,
+			     RK3308_ADC_CH2_MIC_GAIN_MIN,
+			     RK3308_ADC_CH2_MIC_GAIN_MAX,
+			     0, rk3308_codec_adc_3_8_mic_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC MIC Group 2 Left Volume",
+			     RK3308_ADC_ANA_CON01(2),
+			     RK3308_ADC_CH1_MIC_GAIN_SFT,
+			     RK3308_ADC_CH1_MIC_GAIN_MIN,
+			     RK3308_ADC_CH1_MIC_GAIN_MAX,
+			     0, rk3308_codec_adc_3_8_mic_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC MIC Group 2 Right Volume",
+			     RK3308_ADC_ANA_CON01(2),
+			     RK3308_ADC_CH2_MIC_GAIN_SFT,
+			     RK3308_ADC_CH2_MIC_GAIN_MIN,
+			     RK3308_ADC_CH2_MIC_GAIN_MAX,
+			     0, rk3308_codec_adc_3_8_mic_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC MIC Group 3 Left Volume",
+			     RK3308_ADC_ANA_CON01(3),
+			     RK3308_ADC_CH1_MIC_GAIN_SFT,
+			     RK3308_ADC_CH1_MIC_GAIN_MIN,
+			     RK3308_ADC_CH1_MIC_GAIN_MAX,
+			     0, rk3308_codec_adc_3_8_mic_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC MIC Group 3 Right Volume",
+			     RK3308_ADC_ANA_CON01(3),
+			     RK3308_ADC_CH2_MIC_GAIN_SFT,
+			     RK3308_ADC_CH2_MIC_GAIN_MIN,
+			     RK3308_ADC_CH2_MIC_GAIN_MAX,
+			     0, rk3308_codec_adc_3_8_mic_gain_tlv),
+
+	/* ADC ALC */
+	SOC_SINGLE_RANGE_TLV("ADC ALC Group 0 Left Volume",
+			     RK3308_ADC_ANA_CON03(0),
+			     RK3308_ADC_CH1_ALC_GAIN_SFT,
+			     RK3308_ADC_CH1_ALC_GAIN_MIN,
+			     RK3308_ADC_CH1_ALC_GAIN_MAX,
+			     0, rk3308_codec_adc_alc_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC ALC Group 0 Right Volume",
+			     RK3308_ADC_ANA_CON04(0),
+			     RK3308_ADC_CH2_ALC_GAIN_SFT,
+			     RK3308_ADC_CH2_ALC_GAIN_MIN,
+			     RK3308_ADC_CH2_ALC_GAIN_MAX,
+			     0, rk3308_codec_adc_alc_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC ALC Group 1 Left Volume",
+			     RK3308_ADC_ANA_CON03(1),
+			     RK3308_ADC_CH1_ALC_GAIN_SFT,
+			     RK3308_ADC_CH1_ALC_GAIN_MIN,
+			     RK3308_ADC_CH1_ALC_GAIN_MAX,
+			     0, rk3308_codec_adc_alc_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC ALC Group 1 Right Volume",
+			     RK3308_ADC_ANA_CON04(1),
+			     RK3308_ADC_CH2_ALC_GAIN_SFT,
+			     RK3308_ADC_CH2_ALC_GAIN_MIN,
+			     RK3308_ADC_CH2_ALC_GAIN_MAX,
+			     0, rk3308_codec_adc_alc_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC ALC Group 2 Left Volume",
+			     RK3308_ADC_ANA_CON03(2),
+			     RK3308_ADC_CH1_ALC_GAIN_SFT,
+			     RK3308_ADC_CH1_ALC_GAIN_MIN,
+			     RK3308_ADC_CH1_ALC_GAIN_MAX,
+			     0, rk3308_codec_adc_alc_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC ALC Group 2 Right Volume",
+			     RK3308_ADC_ANA_CON04(2),
+			     RK3308_ADC_CH2_ALC_GAIN_SFT,
+			     RK3308_ADC_CH2_ALC_GAIN_MIN,
+			     RK3308_ADC_CH2_ALC_GAIN_MAX,
+			     0, rk3308_codec_adc_alc_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC ALC Group 3 Left Volume",
+			     RK3308_ADC_ANA_CON03(3),
+			     RK3308_ADC_CH1_ALC_GAIN_SFT,
+			     RK3308_ADC_CH1_ALC_GAIN_MIN,
+			     RK3308_ADC_CH1_ALC_GAIN_MAX,
+			     0, rk3308_codec_adc_alc_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC ALC Group 3 Right Volume",
+			     RK3308_ADC_ANA_CON04(3),
+			     RK3308_ADC_CH2_ALC_GAIN_SFT,
+			     RK3308_ADC_CH2_ALC_GAIN_MIN,
+			     RK3308_ADC_CH2_ALC_GAIN_MAX,
+			     0, rk3308_codec_adc_alc_gain_tlv),
+
+	/* DAC LINEOUT */
+	SOC_SINGLE_TLV("DAC LINEOUT Left Volume",
+		       RK3308_DAC_ANA_CON04,
+		       RK3308_DAC_L_LINEOUT_GAIN_SFT,
+		       RK3308_DAC_L_LINEOUT_GAIN_MAX,
+		       0, rk3308_codec_dac_lineout_gain_tlv),
+	SOC_SINGLE_TLV("DAC LINEOUT Right Volume",
+		       RK3308_DAC_ANA_CON04,
+		       RK3308_DAC_R_LINEOUT_GAIN_SFT,
+		       RK3308_DAC_R_LINEOUT_GAIN_MAX,
+		       0, rk3308_codec_dac_lineout_gain_tlv),
+
+	/* DAC HPOUT */
+	SOC_SINGLE_TLV("DAC HPOUT Left Volume",
+		       RK3308_DAC_ANA_CON05,
+		       RK3308_DAC_L_HPOUT_GAIN_SFT,
+		       RK3308_DAC_L_HPOUT_GAIN_MAX,
+		       0, rk3308_codec_dac_hpout_gain_tlv),
+	SOC_SINGLE_TLV("DAC HPOUT Right Volume",
+		       RK3308_DAC_ANA_CON06,
+		       RK3308_DAC_R_HPOUT_GAIN_SFT,
+		       RK3308_DAC_R_HPOUT_GAIN_MAX,
+		       0, rk3308_codec_dac_hpout_gain_tlv),
+
+	/* DAC HPMIX */
+	SOC_SINGLE_RANGE_TLV("DAC HPMIX Left Volume",
+			     RK3308_DAC_ANA_CON12,
+			     RK3308_DAC_L_HPMIX_GAIN_SFT,
+			     RK3308_DAC_L_HPMIX_GAIN_MIN,
+			     RK3308_DAC_L_HPMIX_GAIN_MAX,
+			     0, rk3308_codec_dac_hpmix_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("DAC HPMIX Right Volume",
+			     RK3308_DAC_ANA_CON12,
+			     RK3308_DAC_R_HPMIX_GAIN_SFT,
+			     RK3308_DAC_R_HPMIX_GAIN_MIN,
+			     RK3308_DAC_R_HPMIX_GAIN_MAX,
+			     0, rk3308_codec_dac_hpmix_gain_tlv),
+};
+
+/*
+ * Maybe there are rk3308_codec_get_adc_path_state() and
+ * rk3308_codec_set_adc_path_state() in future.
+ */
+
+static int rk3308_codec_get_dac_path_state(struct rk3308_codec_priv *rk3308)
+{
+	return rk3308->dac_path_state;
+}
+
+static void rk3308_codec_set_dac_path_state(struct rk3308_codec_priv *rk3308,
+					   int state)
+{
+	rk3308->dac_path_state = state;
+}
+
+static void rk3308_headphone_ctl(struct rk3308_codec_priv *rk3308, int on)
+{
+	if (rk3308->hp_ctl_gpio)
+		gpiod_direction_output(rk3308->hp_ctl_gpio, on);
+}
+
+static void rk3308_speaker_ctl(struct rk3308_codec_priv *rk3308, int on)
+{
+	if (rk3308->spk_ctl_gpio)
+		gpiod_direction_output(rk3308->spk_ctl_gpio, on);
+}
+
+static int rk3308_codec_reset(struct snd_soc_codec *codec)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_codec_get_drvdata(codec);
+
+	reset_control_assert(rk3308->reset);
+	usleep_range(2000, 2500);	/* estimated value */
+	reset_control_deassert(rk3308->reset);
+
+	regmap_write(rk3308->regmap, RK3308_GLB_CON, 0x00);
+	usleep_range(200, 300);		/* estimated value */
+	regmap_write(rk3308->regmap, RK3308_GLB_CON,
+		     RK3308_SYS_WORK |
+		     RK3308_DAC_DIG_WORK |
+		     RK3308_ADC_DIG_WORK);
+
+	return 0;
+}
+
+static int rk3308_codec_adc_dig_reset(struct rk3308_codec_priv *rk3308)
+{
+	regmap_update_bits(rk3308->regmap, RK3308_GLB_CON,
+				   RK3308_ADC_DIG_WORK,
+				   RK3308_ADC_DIG_RESET);
+	udelay(50);
+	regmap_update_bits(rk3308->regmap, RK3308_GLB_CON,
+				   RK3308_ADC_DIG_WORK,
+				   RK3308_ADC_DIG_WORK);
+
+	return 0;
+}
+
+static int rk3308_codec_dac_dig_reset(struct rk3308_codec_priv *rk3308)
+{
+	regmap_update_bits(rk3308->regmap, RK3308_GLB_CON,
+				   RK3308_DAC_DIG_WORK,
+				   RK3308_DAC_DIG_RESET);
+	udelay(50);
+	regmap_update_bits(rk3308->regmap, RK3308_GLB_CON,
+				   RK3308_DAC_DIG_WORK,
+				   RK3308_DAC_DIG_WORK);
+
+	return 0;
+}
+
+static int rk3308_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_codec_get_drvdata(codec);
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+	case SND_SOC_BIAS_PREPARE:
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		regcache_cache_only(rk3308->regmap, false);
+		regcache_sync(rk3308->regmap);
+		break;
+	case SND_SOC_BIAS_OFF:
+		break;
+	}
+
+	return 0;
+}
+
+static int rk3308_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			      unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct rk3308_codec_priv *rk3308 = snd_soc_codec_get_drvdata(codec);
+	unsigned int adc_aif1 = 0, adc_aif2 = 0, dac_aif1 = 0, dac_aif2 = 0;
+	int grp, is_master;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		adc_aif2 |= RK3308_ADC_IO_MODE_SLAVE;
+		adc_aif2 |= RK3308_ADC_MODE_SLAVE;
+		dac_aif2 |= RK3308_DAC_IO_MODE_SLAVE;
+		dac_aif2 |= RK3308_DAC_MODE_SLAVE;
+		is_master = 0;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		adc_aif2 |= RK3308_ADC_IO_MODE_MASTER;
+		adc_aif2 |= RK3308_ADC_MODE_MASTER;
+		dac_aif2 |= RK3308_DAC_IO_MODE_MASTER;
+		dac_aif2 |= RK3308_DAC_MODE_MASTER;
+		is_master = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_DSP_A:
+		adc_aif1 |= RK3308_ADC_I2S_MODE_PCM;
+		dac_aif1 |= RK3308_DAC_I2S_MODE_PCM;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		adc_aif1 |= RK3308_ADC_I2S_MODE_I2S;
+		dac_aif1 |= RK3308_DAC_I2S_MODE_I2S;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		adc_aif1 |= RK3308_ADC_I2S_MODE_RJ;
+		dac_aif1 |= RK3308_DAC_I2S_MODE_RJ;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		adc_aif1 |= RK3308_ADC_I2S_MODE_LJ;
+		dac_aif1 |= RK3308_DAC_I2S_MODE_LJ;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		adc_aif1 |= RK3308_ADC_I2S_LRC_POL_NORMAL;
+		adc_aif2 |= RK3308_ADC_I2S_BIT_CLK_POL_NORMAL;
+		dac_aif1 |= RK3308_DAC_I2S_LRC_POL_NORMAL;
+		dac_aif2 |= RK3308_DAC_I2S_BIT_CLK_POL_NORMAL;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		adc_aif1 |= RK3308_ADC_I2S_LRC_POL_REVERSAL;
+		adc_aif2 |= RK3308_ADC_I2S_BIT_CLK_POL_REVERSAL;
+		dac_aif1 |= RK3308_DAC_I2S_LRC_POL_REVERSAL;
+		dac_aif2 |= RK3308_DAC_I2S_BIT_CLK_POL_REVERSAL;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		adc_aif1 |= RK3308_ADC_I2S_LRC_POL_NORMAL;
+		adc_aif2 |= RK3308_ADC_I2S_BIT_CLK_POL_REVERSAL;
+		dac_aif1 |= RK3308_DAC_I2S_LRC_POL_NORMAL;
+		dac_aif2 |= RK3308_DAC_I2S_BIT_CLK_POL_REVERSAL;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		adc_aif1 |= RK3308_ADC_I2S_LRC_POL_REVERSAL;
+		adc_aif2 |= RK3308_ADC_I2S_BIT_CLK_POL_NORMAL;
+		dac_aif1 |= RK3308_DAC_I2S_LRC_POL_REVERSAL;
+		dac_aif2 |= RK3308_DAC_I2S_BIT_CLK_POL_NORMAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/*
+	 * Hold ADC Digital registers start at master mode
+	 *
+	 * There are 8 ADCs and use the same SCLK and LRCK internal for master
+	 * mode, We need to make sure that they are in effect at the same time,
+	 * otherwise they will cause the abnormal clocks.
+	 */
+	if (is_master)
+		regmap_update_bits(rk3308->regmap, RK3308_GLB_CON,
+				   RK3308_ADC_DIG_WORK,
+				   RK3308_ADC_DIG_RESET);
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_DIG_CON01(grp),
+				   RK3308_ADC_I2S_LRC_POL_MSK |
+				   RK3308_ADC_I2S_MODE_MSK,
+				   adc_aif1);
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_DIG_CON02(grp),
+				   RK3308_ADC_IO_MODE_MSK |
+				   RK3308_ADC_MODE_MSK |
+				   RK3308_ADC_I2S_BIT_CLK_POL_MSK,
+				   adc_aif2);
+	}
+
+	/* Hold ADC Digital registers end at master mode */
+	if (is_master)
+		regmap_update_bits(rk3308->regmap, RK3308_GLB_CON,
+				   RK3308_ADC_DIG_WORK,
+				   RK3308_ADC_DIG_WORK);
+
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_DIG_CON01,
+			   RK3308_DAC_I2S_LRC_POL_MSK |
+			   RK3308_DAC_I2S_MODE_MSK,
+			   dac_aif1);
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_DIG_CON02,
+			   RK3308_DAC_IO_MODE_MSK |
+			   RK3308_DAC_MODE_MSK |
+			   RK3308_DAC_I2S_BIT_CLK_POL_MSK,
+			   dac_aif2);
+
+	return 0;
+}
+
+static int rk3308_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct rk3308_codec_priv *rk3308 = snd_soc_codec_get_drvdata(codec);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		unsigned int dac_aif1 = 0, dac_aif2 = 0;
+
+		/* Clear the status of DAC DIG Digital reigisters */
+		rk3308_codec_dac_dig_reset(rk3308);
+
+		switch (params_format(params)) {
+		case SNDRV_PCM_FORMAT_S16_LE:
+			dac_aif1 |= RK3308_DAC_I2S_VALID_LEN_16BITS;
+			break;
+		case SNDRV_PCM_FORMAT_S20_3LE:
+			dac_aif1 |= RK3308_DAC_I2S_VALID_LEN_20BITS;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			dac_aif1 |= RK3308_DAC_I2S_VALID_LEN_24BITS;
+			break;
+		case SNDRV_PCM_FORMAT_S32_LE:
+			dac_aif1 |= RK3308_DAC_I2S_VALID_LEN_32BITS;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		dac_aif1 |= RK3308_DAC_I2S_LR_NORMAL;
+		dac_aif2 |= RK3308_DAC_I2S_WORK;
+
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_DIG_CON01,
+				   RK3308_DAC_I2S_VALID_LEN_MSK |
+				   RK3308_DAC_I2S_LR_MSK,
+				   dac_aif1);
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_DIG_CON02,
+				   RK3308_DAC_I2S_MSK,
+				   dac_aif2);
+	} else {
+		unsigned int adc_aif1 = 0, adc_aif2 = 0;
+		int grp, cur_grp_max;
+
+		/* Clear the status of ADC DIG Digital reigisters */
+		rk3308_codec_adc_dig_reset(rk3308);
+
+		switch (params_format(params)) {
+		case SNDRV_PCM_FORMAT_S16_LE:
+			adc_aif1 |= RK3308_ADC_I2S_VALID_LEN_16BITS;
+			break;
+		case SNDRV_PCM_FORMAT_S20_3LE:
+			adc_aif1 |= RK3308_ADC_I2S_VALID_LEN_20BITS;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			adc_aif1 |= RK3308_ADC_I2S_VALID_LEN_24BITS;
+			break;
+		case SNDRV_PCM_FORMAT_S32_LE:
+			adc_aif1 |= RK3308_ADC_I2S_VALID_LEN_32BITS;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		switch (params_channels(params)) {
+		case 1:
+			adc_aif1 |= RK3308_ADC_I2S_MONO;
+			cur_grp_max = 0;
+			break;
+		case 2:
+		case 4:
+		case 6:
+		case 8:
+			adc_aif1 |= RK3308_ADC_I2S_STEREO;
+			cur_grp_max = (params_channels(params) - 1) / 2;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		adc_aif1 |= RK3308_ADC_I2S_LR_NORMAL;
+		adc_aif2 |= RK3308_ADC_I2S_WORK;
+
+		for (grp = 0; grp <= cur_grp_max; grp++) {
+			regmap_update_bits(rk3308->regmap, RK3308_ADC_DIG_CON01(grp),
+					   RK3308_ADC_I2S_VALID_LEN_MSK |
+					   RK3308_ADC_I2S_LR_MSK |
+					   RK3308_ADC_I2S_TYPE_MSK,
+					   adc_aif1);
+			regmap_update_bits(rk3308->regmap, RK3308_ADC_DIG_CON02(grp),
+					   RK3308_ADC_I2S_MSK,
+					   adc_aif2);
+		}
+	}
+
+	return 0;
+}
+
+static int rk3308_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct rk3308_codec_priv *rk3308 = snd_soc_codec_get_drvdata(codec);
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		int dgain;
+
+		if (mute) {
+			for (dgain = 0x2; dgain <= 0x7; dgain++) {
+				/*
+				 * Keep the max -> min digital CIC interpolation
+				 * filter gain step by step.
+				 *
+				 * loud: 0x2; whisper: 0x7
+				 */
+				regmap_update_bits(rk3308->regmap,
+						   RK3308_DAC_DIG_CON04,
+						   RK3308_DAC_CIC_IF_GAIN_MSK,
+						   dgain);
+				usleep_range(200, 300);  /* estimated value */
+			}
+
+#if !DEBUG_POP_ALWAYS
+			rk3308_headphone_ctl(rk3308, 0);
+			rk3308_speaker_ctl(rk3308, 0);
+#endif
+		} else {
+#if !DEBUG_POP_ALWAYS
+			if (rk3308->dac_output == DAC_LINEOUT)
+				rk3308_speaker_ctl(rk3308, 1);
+			else if (rk3308->dac_output == DAC_HPOUT)
+				rk3308_headphone_ctl(rk3308, 1);
+#endif
+
+			for (dgain = 0x7; dgain >= 0x2; dgain--) {
+				/*
+				 * Keep the min -> max digital CIC interpolation
+				 * filter gain step by step
+				 *
+				 * loud: 0x2; whisper: 0x7
+				 */
+				regmap_update_bits(rk3308->regmap,
+						   RK3308_DAC_DIG_CON04,
+						   RK3308_DAC_CIC_IF_GAIN_MSK,
+						   dgain);
+				usleep_range(200, 300);  /* estimated value */
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_dac_lineout_enable(struct rk3308_codec_priv *rk3308)
+{
+	/* Step 06 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+			   RK3308_DAC_L_LINEOUT_EN |
+			   RK3308_DAC_R_LINEOUT_EN,
+			   RK3308_DAC_L_LINEOUT_EN |
+			   RK3308_DAC_R_LINEOUT_EN);
+
+	udelay(20);
+
+	/* Step 17 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+			   RK3308_DAC_L_LINEOUT_UNMUTE |
+			   RK3308_DAC_R_LINEOUT_UNMUTE,
+			   RK3308_DAC_L_LINEOUT_UNMUTE |
+			   RK3308_DAC_R_LINEOUT_UNMUTE);
+	udelay(20);
+
+	return 0;
+}
+
+static int rk3308_codec_dac_lineout_disable(struct rk3308_codec_priv *rk3308)
+{
+	/* Step 06 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+			   RK3308_DAC_L_LINEOUT_EN |
+			   RK3308_DAC_R_LINEOUT_EN,
+			   RK3308_DAC_L_LINEOUT_DIS |
+			   RK3308_DAC_R_LINEOUT_DIS);
+
+	/* Step 17 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+			   RK3308_DAC_L_LINEOUT_UNMUTE |
+			   RK3308_DAC_R_LINEOUT_UNMUTE,
+			   RK3308_DAC_L_LINEOUT_MUTE |
+			   RK3308_DAC_R_LINEOUT_MUTE);
+
+	return 0;
+}
+
+static int rk3308_codec_dac_hpout_enable(struct rk3308_codec_priv *rk3308)
+{
+	/* Step 03 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON01,
+			   RK3308_DAC_POP_SOUND_L_MSK |
+			   RK3308_DAC_POP_SOUND_R_MSK,
+			   RK3308_DAC_POP_SOUND_L_WORK |
+			   RK3308_DAC_POP_SOUND_R_WORK);
+
+	udelay(20);
+
+	/* Step 07 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_EN |
+			   RK3308_DAC_R_HPOUT_EN,
+			   RK3308_DAC_L_HPOUT_EN |
+			   RK3308_DAC_R_HPOUT_EN);
+
+	udelay(20);
+
+	/* Step 08 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_WORK |
+			   RK3308_DAC_R_HPOUT_WORK,
+			   RK3308_DAC_L_HPOUT_WORK |
+			   RK3308_DAC_R_HPOUT_WORK);
+
+	udelay(20);
+
+	/* Step 16 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_UNMUTE |
+			   RK3308_DAC_R_HPOUT_UNMUTE,
+			   RK3308_DAC_L_HPOUT_UNMUTE |
+			   RK3308_DAC_R_HPOUT_UNMUTE);
+
+	udelay(20);
+
+	return 0;
+}
+
+static int rk3308_codec_dac_hpout_disable(struct rk3308_codec_priv *rk3308)
+{
+	/* Step 03 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON01,
+			   RK3308_DAC_POP_SOUND_L_MSK |
+			   RK3308_DAC_POP_SOUND_R_MSK,
+			   RK3308_DAC_POP_SOUND_L_INIT |
+			   RK3308_DAC_POP_SOUND_R_INIT);
+
+	/* Step 07 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_EN |
+			   RK3308_DAC_R_HPOUT_EN,
+			   RK3308_DAC_L_HPOUT_DIS |
+			   RK3308_DAC_R_HPOUT_DIS);
+
+	/* Step 08 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_WORK |
+			   RK3308_DAC_R_HPOUT_WORK,
+			   RK3308_DAC_L_HPOUT_INIT |
+			   RK3308_DAC_R_HPOUT_INIT);
+
+	/* Step 16 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_UNMUTE |
+			   RK3308_DAC_R_HPOUT_UNMUTE,
+			   RK3308_DAC_L_HPOUT_MUTE |
+			   RK3308_DAC_R_HPOUT_MUTE);
+
+	return 0;
+}
+
+static int rk3308_codec_dac_switch(struct rk3308_codec_priv *rk3308,
+				   int dac_output)
+{	int ret = 0;
+
+	if (rk3308->dac_output == dac_output) {
+		dev_info(rk3308->plat_dev,
+			 "Don't need to change dac_output: %d\n", dac_output);
+		goto out;
+	}
+
+	switch (dac_output) {
+	case DAC_LINEOUT:
+	case DAC_HPOUT:
+	case DAC_LINEOUT_HPOUT:
+		break;
+	default:
+		dev_err(rk3308->plat_dev, "Unknown value: %d\n", dac_output);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (rk3308_codec_get_dac_path_state(rk3308) == PATH_BUSY) {
+		/*
+		 * We can only switch the audio path to LINEOUT or HPOUT on
+		 * codec during playbacking, otherwise, just update the
+		 * dac_output flag.
+		 */
+		switch (dac_output) {
+		case DAC_LINEOUT:
+			rk3308_headphone_ctl(rk3308, 0);
+			rk3308_speaker_ctl(rk3308, 1);
+			rk3308_codec_dac_hpout_disable(rk3308);
+			rk3308_codec_dac_lineout_enable(rk3308);
+			break;
+		case DAC_HPOUT:
+			rk3308_speaker_ctl(rk3308, 0);
+			rk3308_headphone_ctl(rk3308, 1);
+			rk3308_codec_dac_lineout_disable(rk3308);
+			rk3308_codec_dac_hpout_enable(rk3308);
+			break;
+		case DAC_LINEOUT_HPOUT:
+			rk3308_speaker_ctl(rk3308, 1);
+			rk3308_headphone_ctl(rk3308, 1);
+			rk3308_codec_dac_lineout_enable(rk3308);
+			rk3308_codec_dac_hpout_enable(rk3308);
+			break;
+		default:
+			break;
+		}
+	}
+
+	rk3308->dac_output = dac_output;
+out:
+	dev_dbg(rk3308->plat_dev, "switch dac_output to: %d\n",
+		 rk3308->dac_output);
+
+	return ret;
+}
+
+static int rk3308_codec_dac_enable(struct rk3308_codec_priv *rk3308)
+{
+	/*
+	 * Note1. If the ACODEC_DAC_ANA_CON12[6] or ACODEC_DAC_ANA_CON12[2]
+	 * is set to 0x1, ignoring the step9~12.
+	 */
+
+	/*
+	 * Note2. If the ACODEC_ DAC_ANA_CON12[7] or ACODEC_DAC_ANA_CON12[3]
+	 * is set to 0x1, the ADC0 or ADC1 should be enabled firstly, and
+	 * please refer to Enable ADC Configuration Standard Usage Flow(expect
+	 * step7~step9,step14).
+	 */
+
+	/*
+	 * Note3. If no opening the line out, ignoring the step6, step17 and
+	 * step19.
+	 */
+
+	/*
+	 * Note4. If no opening the headphone out, ignoring the step3,step7~8,
+	 * step16 and step18.
+	 */
+
+	/*
+	 * Note5. In the step18, adjust the register step by step to the
+	 * appropriate value and taking 10ms as one time step
+	 */
+
+	/*
+	 * 1. Set the ACODEC_DAC_ANA_CON0[0] to 0x1, to enable the current
+	 * source of DAC
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON00,
+			   RK3308_DAC_CURRENT_MSK,
+			   RK3308_DAC_CURRENT_EN);
+
+	udelay(20);
+
+	/*
+	 * 2. Set the ACODEC_DAC_ANA_CON1[6] and ACODEC_DAC_ANA_CON1[2] to 0x1,
+	 * to enable the reference voltage buffer
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON01,
+			   RK3308_DAC_BUF_REF_L_MSK |
+			   RK3308_DAC_BUF_REF_R_MSK,
+			   RK3308_DAC_BUF_REF_L_EN |
+			   RK3308_DAC_BUF_REF_R_EN);
+
+	/* Waiting the stable reference voltage */
+	udelay(50);
+
+	if (rk3308->dac_output == DAC_HPOUT ||
+	    rk3308->dac_output == DAC_LINEOUT_HPOUT) {
+		/* Step 03 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON01,
+				   RK3308_DAC_POP_SOUND_L_MSK |
+				   RK3308_DAC_POP_SOUND_R_MSK,
+				   RK3308_DAC_POP_SOUND_L_WORK |
+				   RK3308_DAC_POP_SOUND_R_WORK);
+
+		udelay(20);
+	}
+
+	/* Step 04 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON13,
+			   RK3308_DAC_L_HPMIX_EN |
+			   RK3308_DAC_R_HPMIX_EN,
+			   RK3308_DAC_L_HPMIX_EN |
+			   RK3308_DAC_R_HPMIX_EN);
+
+	/* Waiting the stable HPMIX */
+	udelay(50);
+
+	/* Step 05 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON13,
+			   RK3308_DAC_L_HPMIX_WORK |
+			   RK3308_DAC_R_HPMIX_WORK,
+			   RK3308_DAC_L_HPMIX_WORK |
+			   RK3308_DAC_R_HPMIX_WORK);
+
+	udelay(20);
+
+	if (rk3308->dac_output == DAC_LINEOUT ||
+	    rk3308->dac_output == DAC_LINEOUT_HPOUT) {
+		/* Step 06 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+				   RK3308_DAC_L_LINEOUT_EN |
+				   RK3308_DAC_R_LINEOUT_EN,
+				   RK3308_DAC_L_LINEOUT_EN |
+				   RK3308_DAC_R_LINEOUT_EN);
+
+		udelay(20);
+	}
+
+	if (rk3308->dac_output == DAC_HPOUT ||
+	    rk3308->dac_output == DAC_LINEOUT_HPOUT) {
+		/* Step 07 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+				   RK3308_DAC_L_HPOUT_EN |
+				   RK3308_DAC_R_HPOUT_EN,
+				   RK3308_DAC_L_HPOUT_EN |
+				   RK3308_DAC_R_HPOUT_EN);
+
+		udelay(20);
+
+		/* Step 08 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+				   RK3308_DAC_L_HPOUT_WORK |
+				   RK3308_DAC_R_HPOUT_WORK,
+				   RK3308_DAC_L_HPOUT_WORK |
+				   RK3308_DAC_R_HPOUT_WORK);
+
+		udelay(20);
+	}
+
+	/* Step 09 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON02,
+			   RK3308_DAC_L_REF_EN |
+			   RK3308_DAC_R_REF_EN,
+			   RK3308_DAC_L_REF_EN |
+			   RK3308_DAC_R_REF_EN);
+
+	udelay(20);
+
+	/* Step 10 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON02,
+			   RK3308_DAC_L_CLK_EN |
+			   RK3308_DAC_R_CLK_EN,
+			   RK3308_DAC_L_CLK_EN |
+			   RK3308_DAC_R_CLK_EN);
+
+	udelay(20);
+
+	/* Step 11 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON02,
+			   RK3308_DAC_L_DAC_EN |
+			   RK3308_DAC_R_DAC_EN,
+			   RK3308_DAC_L_DAC_EN |
+			   RK3308_DAC_R_DAC_EN);
+
+	udelay(20);
+
+	/* Step 12 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON02,
+			   RK3308_DAC_L_DAC_WORK |
+			   RK3308_DAC_R_DAC_WORK,
+			   RK3308_DAC_L_DAC_WORK |
+			   RK3308_DAC_R_DAC_WORK);
+
+	udelay(20);
+
+	/* Step 13 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON12,
+			   RK3308_DAC_L_HPMIX_SEL_MSK |
+			   RK3308_DAC_R_HPMIX_SEL_MSK,
+			   RK3308_DAC_L_HPMIX_I2S |
+			   RK3308_DAC_R_HPMIX_I2S);
+
+	udelay(20);
+
+	/* Step 14 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON13,
+			   RK3308_DAC_L_HPMIX_UNMUTE |
+			   RK3308_DAC_R_HPMIX_UNMUTE,
+			   RK3308_DAC_L_HPMIX_UNMUTE |
+			   RK3308_DAC_R_HPMIX_UNMUTE);
+
+	udelay(20);
+
+	/* Step 15 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON12,
+			   RK3308_DAC_L_HPMIX_GAIN_MSK |
+			   RK3308_DAC_R_HPMIX_GAIN_MSK,
+			   RK3308_DAC_L_HPMIX_GAIN_NDB_6 |
+			   RK3308_DAC_R_HPMIX_GAIN_NDB_6);
+
+	udelay(20);
+
+	if (rk3308->dac_output == DAC_HPOUT ||
+	    rk3308->dac_output == DAC_LINEOUT_HPOUT) {
+		/* Step 16 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+				   RK3308_DAC_L_HPOUT_UNMUTE |
+				   RK3308_DAC_R_HPOUT_UNMUTE,
+				   RK3308_DAC_L_HPOUT_UNMUTE |
+				   RK3308_DAC_R_HPOUT_UNMUTE);
+
+		udelay(20);
+	}
+
+	if (rk3308->dac_output == DAC_LINEOUT ||
+	    rk3308->dac_output == DAC_LINEOUT_HPOUT) {
+		/* Step 17 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+				   RK3308_DAC_L_LINEOUT_UNMUTE |
+				   RK3308_DAC_R_LINEOUT_UNMUTE,
+				   RK3308_DAC_L_LINEOUT_UNMUTE |
+				   RK3308_DAC_R_LINEOUT_UNMUTE);
+		udelay(20);
+	}
+
+	if (rk3308->dac_output == DAC_HPOUT ||
+	    rk3308->dac_output == DAC_LINEOUT_HPOUT) {
+		/* Step 18 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON05,
+				   RK3308_DAC_L_HPOUT_GAIN_MSK,
+				   RK3308_DAC_L_HPOUT_GAIN_NDB_39);
+
+		/* Step 18 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON06,
+				   RK3308_DAC_R_HPOUT_GAIN_MSK,
+				   RK3308_DAC_R_HPOUT_GAIN_NDB_39);
+
+		udelay(20);
+	}
+
+	if (rk3308->dac_output == DAC_LINEOUT ||
+	    rk3308->dac_output == DAC_LINEOUT_HPOUT) {
+		/* Step 19 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+				   RK3308_DAC_L_LINEOUT_GAIN_MSK |
+				   RK3308_DAC_R_LINEOUT_GAIN_MSK,
+				   RK3308_DAC_L_LINEOUT_GAIN_NDB_6 |
+				   RK3308_DAC_R_LINEOUT_GAIN_NDB_6);
+
+		udelay(20);
+	}
+
+	/* TODO: TRY TO TEST DRIVE STRENGTH */
+
+	return 0;
+}
+
+static int rk3308_codec_digital_fadeout(struct rk3308_codec_priv *rk3308)
+{
+	unsigned int l_dgain, r_dgain;
+
+	/*
+	 * Note. In the step2, adjusting the register step by step to
+	 * the appropriate value and taking 20ms as time step
+	 */
+	regmap_read(rk3308->regmap, RK3308_DAC_ANA_CON05, &l_dgain);
+	l_dgain &= RK3308_DAC_L_HPOUT_GAIN_MSK;
+
+	regmap_read(rk3308->regmap, RK3308_DAC_ANA_CON06, &r_dgain);
+	r_dgain &= RK3308_DAC_R_HPOUT_GAIN_MSK;
+
+	if (l_dgain != r_dgain)
+		pr_warn("HPOUT l_dgain: 0x%x != r_dgain: 0x%x\n",
+			l_dgain, r_dgain);
+
+	/*
+	 * We'd better change the gain of the left and right channels
+	 * at the same time to avoid different listening
+	 */
+	while (l_dgain >= RK3308_DAC_L_HPOUT_GAIN_NDB_39) {
+		/* Step 02 decrease dgains for de-pop */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON05,
+				   RK3308_DAC_L_HPOUT_GAIN_MSK,
+				   l_dgain);
+
+		/* Step 02 decrease dgains for de-pop */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON06,
+				   RK3308_DAC_R_HPOUT_GAIN_MSK,
+				   r_dgain);
+
+		usleep_range(200, 300);  /* estimated value */
+
+		if (l_dgain == RK3308_DAC_L_HPOUT_GAIN_NDB_39)
+			break;
+
+		l_dgain--;
+		r_dgain--;
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_dac_disable(struct rk3308_codec_priv *rk3308)
+{
+	/* Step 00, the min digital gain for mute */
+
+	/* Step 01 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+			   RK3308_DAC_L_LINEOUT_GAIN_MSK |
+			   RK3308_DAC_R_LINEOUT_GAIN_MSK,
+			   RK3308_DAC_L_LINEOUT_GAIN_NDB_6 |
+			   RK3308_DAC_R_LINEOUT_GAIN_NDB_6);
+
+	/* Step 02 */
+	rk3308_codec_digital_fadeout(rk3308);
+
+	/* Step 03 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON13,
+			   RK3308_DAC_L_HPMIX_UNMUTE |
+			   RK3308_DAC_R_HPMIX_UNMUTE,
+			   RK3308_DAC_L_HPMIX_MUTE |
+			   RK3308_DAC_R_HPMIX_MUTE);
+
+	/* Step 04 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON12,
+			   RK3308_DAC_L_HPMIX_SEL_MSK |
+			   RK3308_DAC_R_HPMIX_SEL_MSK,
+			   RK3308_DAC_L_HPMIX_NONE |
+			   RK3308_DAC_R_HPMIX_NONE);
+	/* Step 05 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_UNMUTE |
+			   RK3308_DAC_R_HPOUT_UNMUTE,
+			   RK3308_DAC_L_HPOUT_MUTE |
+			   RK3308_DAC_R_HPOUT_MUTE);
+
+	/* Step 06 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON02,
+			   RK3308_DAC_L_DAC_WORK |
+			   RK3308_DAC_R_DAC_WORK,
+			   RK3308_DAC_L_DAC_INIT |
+			   RK3308_DAC_R_DAC_INIT);
+
+	/* Step 07 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_EN |
+			   RK3308_DAC_R_HPOUT_EN,
+			   RK3308_DAC_L_HPOUT_DIS |
+			   RK3308_DAC_R_HPOUT_DIS);
+
+	/* Step 08 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+			   RK3308_DAC_L_LINEOUT_UNMUTE |
+			   RK3308_DAC_R_LINEOUT_UNMUTE,
+			   RK3308_DAC_L_LINEOUT_MUTE |
+			   RK3308_DAC_R_LINEOUT_MUTE);
+
+	/* Step 09 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+			   RK3308_DAC_L_LINEOUT_EN |
+			   RK3308_DAC_R_LINEOUT_EN,
+			   RK3308_DAC_L_LINEOUT_DIS |
+			   RK3308_DAC_R_LINEOUT_DIS);
+
+	/* Step 10 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON13,
+			   RK3308_DAC_L_HPMIX_EN |
+			   RK3308_DAC_R_HPMIX_EN,
+			   RK3308_DAC_L_HPMIX_DIS |
+			   RK3308_DAC_R_HPMIX_DIS);
+
+	/* Step 11 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON02,
+			   RK3308_DAC_L_DAC_EN |
+			   RK3308_DAC_R_DAC_EN,
+			   RK3308_DAC_L_DAC_DIS |
+			   RK3308_DAC_R_DAC_DIS);
+
+	/* Step 12 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON02,
+			   RK3308_DAC_L_CLK_EN |
+			   RK3308_DAC_R_CLK_EN,
+			   RK3308_DAC_L_CLK_DIS |
+			   RK3308_DAC_R_CLK_DIS);
+
+	/* Step 13 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON02,
+			   RK3308_DAC_L_REF_EN |
+			   RK3308_DAC_R_REF_EN,
+			   RK3308_DAC_L_REF_DIS |
+			   RK3308_DAC_R_REF_DIS);
+
+	/* Step 14 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON01,
+			   RK3308_DAC_POP_SOUND_L_MSK |
+			   RK3308_DAC_POP_SOUND_R_MSK,
+			   RK3308_DAC_POP_SOUND_L_INIT |
+			   RK3308_DAC_POP_SOUND_R_INIT);
+
+	/* Step 15 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON01,
+			   RK3308_DAC_BUF_REF_L_EN |
+			   RK3308_DAC_BUF_REF_R_EN,
+			   RK3308_DAC_BUF_REF_L_DIS |
+			   RK3308_DAC_BUF_REF_R_DIS);
+
+	/* Step 16 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON00,
+			   RK3308_DAC_CURRENT_EN,
+			   RK3308_DAC_CURRENT_DIS);
+
+	/* Step 17 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_WORK |
+			   RK3308_DAC_R_HPOUT_WORK,
+			   RK3308_DAC_L_HPOUT_INIT |
+			   RK3308_DAC_R_HPOUT_INIT);
+
+	/* Step 18 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON13,
+			   RK3308_DAC_L_HPMIX_WORK |
+			   RK3308_DAC_R_HPMIX_WORK,
+			   RK3308_DAC_L_HPMIX_INIT |
+			   RK3308_DAC_R_HPMIX_INIT);
+
+	/* Step 19 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON12,
+			   RK3308_DAC_L_HPMIX_GAIN_MSK |
+			   RK3308_DAC_R_HPMIX_GAIN_MSK,
+			   RK3308_DAC_L_HPMIX_GAIN_NDB_6 |
+			   RK3308_DAC_R_HPMIX_GAIN_NDB_6);
+
+	/*
+	 * Note2. If the ACODEC_DAC_ANA_CON12[7] or ACODEC_DAC_ANA_CON12[3]
+	 * is set to 0x1, add the steps from the section Disable ADC
+	 * Configuration Standard Usage Flow after complete the step 19
+	 *
+	 * IF USING LINE-IN
+	 * rk3308_codec_adc_ana_disable(rk3308);
+	 */
+
+	return 0;
+}
+
+static int rk3308_codec_power_on(struct snd_soc_codec *codec)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_codec_get_drvdata(codec);
+	unsigned int v;
+
+	/* 1. Supply the power of digital part and reset the Audio Codec */
+	/* Do nothing */
+
+	/*
+	 * 2. Configure ACODEC_DAC_ANA_CON1[1:0] and ACODEC_DAC_ANA_CON1[5:4]
+	 *    to 0x1, to setup dc voltage of the DAC channel output
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON01,
+			   RK3308_DAC_POP_SOUND_L_MSK,
+			   RK3308_DAC_POP_SOUND_L_INIT);
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON01,
+			   RK3308_DAC_POP_SOUND_R_MSK,
+			   RK3308_DAC_POP_SOUND_R_INIT);
+
+	/*
+	 * 3. Configure the register ACODEC_ADC_ANA_CON10[6:0] to 0x1
+	 *
+	 * Note: Only the reg (ADC_ANA_CON10+0x0)[6:0] represent the control
+	 * signal to select current to pre-charge/dis_charge
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON10(0),
+			   RK3308_ADC_CURRENT_CHARGE_MSK,
+			   RK3308_ADC_SEL_I_64(1));
+
+	/* 4. Supply the power of the analog part(AVDD,AVDDRV) */
+
+	/*
+	 * 5. Configure the register ACODEC_ADC_ANA_CON10[7] to 0x1 to setup
+	 *    reference voltage
+	 *
+	 * Note: Only the reg (ADC_ANA_CON10+0x0)[7] represent the enable
+	 * signal of reference voltage module
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON10(0),
+			   RK3308_ADC_REF_EN, RK3308_ADC_REF_EN);
+
+	/*
+	 * 6. Change the register ACODEC_ADC_ANA_CON10[6:0] from the 0x1 to
+	 *    0x7f step by step or configure the ACODEC_ADC_ANA_CON10[6:0] to
+	 *    0x7f directly. The suggestion slot time of the step is 20ms.
+	 */
+	for (v = 0x1; v <= 0x7f; v++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON10(0),
+				   RK3308_ADC_CURRENT_CHARGE_MSK,
+				   v);
+		udelay(50);
+	}
+
+	/* 7. Wait until the voltage of VCM keeps stable at the AVDD/2 */
+	msleep(20);	/* estimated value */
+
+	/*
+	 * 8. Configure the register ACODEC_ADC_ANA_CON10[6:0] to the
+	 *    appropriate value(expect 0x0) for reducing power.
+	 */
+
+	 /* VENDOR: choose an appropriate charge value */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON10(0),
+			   RK3308_ADC_CURRENT_CHARGE_MSK, 0x7c);
+
+	return 0;
+}
+
+static int rk3308_codec_power_off(struct snd_soc_codec *codec)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_codec_get_drvdata(codec);
+	unsigned int v;
+
+	/*
+	 * 1. Keep the power on and disable the DAC and ADC path according to
+	 *    the section power on configuration standard usage flow.
+	 */
+
+	/* 2. Configure the register ACODEC_ADC_ANA_CON10[6:0] to 0x1 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON10(0),
+			   RK3308_ADC_CURRENT_CHARGE_MSK,
+			   RK3308_ADC_SEL_I_64(1));
+
+	/* 3. Configure the register ACODEC_ADC_ANA_CON10[7] to 0x0 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON10(0),
+			   RK3308_ADC_REF_EN,
+			   RK3308_ADC_REF_DIS);
+
+	/*
+	 * 4.Change the register ACODEC_ADC_ANA_CON10[6:0] from the 0x1 to 0x7f
+	 *   step by step or configure the ACODEC_ADC_ANA_CON10[6:0] to 0x7f
+	 *   directly. The suggestion slot time of the step is 20ms
+	 */
+	for (v = 0x1; v <= 0x7f; v++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON10(0),
+				   RK3308_ADC_CURRENT_CHARGE_MSK,
+				   v);
+		udelay(50);
+	}
+
+	/* 5. Wait until the voltage of VCM keeps stable at the AGND */
+	msleep(20);	/* estimated value */
+
+	/* 6. Power off the analog power supply */
+	/* 7. Power off the digital power supply */
+
+	/* Do something via hardware */
+
+	return 0;
+}
+
+static int rk3308_codec_headset_detect_enable(struct rk3308_codec_priv *rk3308)
+{
+	/*
+	 * Set ACODEC_DAC_ANA_CON0[1] to 0x1, to enable the headset insert
+	 * detection
+	 *
+	 * Note. When the voltage of PAD HPDET> 8*AVDD/9, the output value of
+	 * the pin_hpdet will be set to 0x1 and assert a interrupt
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON00,
+			   RK3308_DAC_HEADPHONE_DET_MSK,
+			   RK3308_DAC_HEADPHONE_DET_EN);
+
+	return 0;
+}
+
+static int rk3308_codec_headset_detect_disable(struct rk3308_codec_priv *rk3308)
+{
+	/*
+	 * Set ACODEC_DAC_ANA_CON0[1] to 0x0, to disable the headset insert
+	 * detection
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON00,
+			   RK3308_DAC_HEADPHONE_DET_MSK,
+			   RK3308_DAC_HEADPHONE_DET_DIS);
+
+	return 0;
+}
+
+static int check_micbias(int micbias)
+{
+	switch (micbias) {
+	case RK3308_ADC_MICBIAS_VOLT_0_85:
+	case RK3308_ADC_MICBIAS_VOLT_0_8:
+	case RK3308_ADC_MICBIAS_VOLT_0_75:
+	case RK3308_ADC_MICBIAS_VOLT_0_7:
+	case RK3308_ADC_MICBIAS_VOLT_0_65:
+	case RK3308_ADC_MICBIAS_VOLT_0_6:
+	case RK3308_ADC_MICBIAS_VOLT_0_55:
+	case RK3308_ADC_MICBIAS_VOLT_0_5:
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int rk3308_codec_micbias_enable(struct rk3308_codec_priv *rk3308,
+				       int micbias)
+{
+	int ret;
+
+	/* 0. Power up the ACODEC and keep the AVDDH stable */
+
+	/* Step 1. Configure ACODEC_ADC_ANA_CON7[2:0] to the certain value */
+	ret = check_micbias(micbias);
+	if (ret < 0) {
+		dev_err(rk3308->plat_dev, "This is an invalid micbias: %d\n",
+			micbias);
+		return ret;
+	}
+
+	/*
+	 * Note: Only the reg (ADC_ANA_CON7+0x0)[2:0] represent the level range
+	 * control signal of MICBIAS voltage
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON07(0),
+			   RK3308_ADC_LEVEL_RANGE_MICBIAS_MSK,
+			   micbias);
+
+	/* Step 2. Wait until the VCMH keep stable */
+	msleep(20);	/* estimated value */
+
+	/*
+	 * Step 3. Configure ACODEC_ADC_ANA_CON8[4] to 0x1
+	 *
+	 * Note: Only the reg (ADC_ANA_CON8+0x0)[4] represent the enable
+	 * signal of current source for MICBIAS
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON08(0),
+			   RK3308_ADC_MICBIAS_CURRENT_MSK,
+			   RK3308_ADC_MICBIAS_CURRENT_EN);
+
+	/*
+	 * Step 4. Configure the (ADC_ANA_CON7+0x40)[3] or
+	 * (ADC_ANA_CON7+0x80)[3] to 0x1.
+	 *
+	 * (ADC_ANA_CON7+0x40)[3] used to control the MICBIAS1, and
+	 * (ADC_ANA_CON7+0x80)[3] used to control the MICBIAS2
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON07(1),
+			   RK3308_ADC_MIC_BIAS_BUF_EN,
+			   RK3308_ADC_MIC_BIAS_BUF_EN);
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON07(2),
+			   RK3308_ADC_MIC_BIAS_BUF_EN,
+			   RK3308_ADC_MIC_BIAS_BUF_EN);
+
+	return 0;
+}
+
+static int rk3308_codec_micbias_disable(struct rk3308_codec_priv *rk3308)
+{
+	/* Step 0. Enable the MICBIAS and keep the Audio Codec stable */
+	/* Do nothing */
+
+	/*
+	 * Step 1. Configure the (ADC_ANA_CON7+0x40)[3] or
+	 * (ADC_ANA_CON7+0x80)[3] to 0x0
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON07(1),
+			   RK3308_ADC_MIC_BIAS_BUF_EN,
+			   RK3308_ADC_MIC_BIAS_BUF_DIS);
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON07(2),
+			   RK3308_ADC_MIC_BIAS_BUF_EN,
+			   RK3308_ADC_MIC_BIAS_BUF_DIS);
+
+	/*
+	 * Step 2. Configure ACODEC_ADC_ANA_CON8[4] to 0x0
+	 *
+	 * Note: Only the reg (ADC_ANA_CON8+0x0)[4] represent the enable
+	 * signal of current source for MICBIAS
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON08(0),
+			   RK3308_ADC_MICBIAS_CURRENT_MSK,
+			   RK3308_ADC_MICBIAS_CURRENT_DIS);
+
+	return 0;
+}
+
+static int rk3308_codec_alc_enable(struct rk3308_codec_priv *rk3308)
+{
+	int grp = rk3308->adc_cur_grp;
+
+	/*
+	 * 1. Set he max level and min level of the ALC need to control.
+	 *
+	 * These values are estimated
+	 */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ALC_L_DIG_CON05(grp),
+				   RK3308_AGC_LO_8BITS_AGC_MAX_MSK,
+				   0x26);
+		regmap_update_bits(rk3308->regmap, RK3308_ALC_R_DIG_CON05(grp),
+				   RK3308_AGC_LO_8BITS_AGC_MAX_MSK,
+				   0x26);
+
+		regmap_update_bits(rk3308->regmap, RK3308_ALC_L_DIG_CON06(grp),
+				   RK3308_AGC_HI_8BITS_AGC_MAX_MSK,
+				   0x40);
+		regmap_update_bits(rk3308->regmap, RK3308_ALC_R_DIG_CON06(grp),
+				   RK3308_AGC_HI_8BITS_AGC_MAX_MSK,
+				   0x40);
+
+		regmap_update_bits(rk3308->regmap, RK3308_ALC_L_DIG_CON07(grp),
+				   RK3308_AGC_LO_8BITS_AGC_MIN_MSK,
+				   0x36);
+		regmap_update_bits(rk3308->regmap, RK3308_ALC_R_DIG_CON07(grp),
+				   RK3308_AGC_LO_8BITS_AGC_MIN_MSK,
+				   0x36);
+
+		regmap_update_bits(rk3308->regmap, RK3308_ALC_L_DIG_CON08(grp),
+				   RK3308_AGC_LO_8BITS_AGC_MIN_MSK,
+				   0x20);
+		regmap_update_bits(rk3308->regmap, RK3308_ALC_R_DIG_CON08(grp),
+				   RK3308_AGC_LO_8BITS_AGC_MIN_MSK,
+				   0x20);
+	}
+
+	/*
+	 * 2. Set ACODEC_ALC_DIG_CON4[2:0] according to the sample rate
+	 *
+	 * By default is 44.1KHz for sample.
+	 */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ALC_L_DIG_CON04(grp),
+				   RK3308_AGC_APPROX_RATE_MSK,
+				   RK3308_AGC_APPROX_RATE_44_1K);
+
+		regmap_update_bits(rk3308->regmap, RK3308_ALC_R_DIG_CON04(grp),
+				   RK3308_AGC_APPROX_RATE_MSK,
+				   RK3308_AGC_APPROX_RATE_44_1K);
+	}
+
+#if ENABLE_AGC
+	/* 3. Set ACODEC_ALC_DIG_CON9[6] to 0x1, to enable the ALC module */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ALC_L_DIG_CON09(grp),
+				   RK3308_AGC_FUNC_SEL_MSK,
+				   RK3308_AGC_FUNC_SEL_EN);
+
+		regmap_update_bits(rk3308->regmap, RK3308_ALC_R_DIG_CON09(grp),
+				   RK3308_AGC_FUNC_SEL_MSK,
+				   RK3308_AGC_FUNC_SEL_EN);
+	}
+
+	/*
+	 * 4. Set ACODEC_ADC_ANA_CON11[1:0], (ACODEC_ADC_ANA_CON11+0x40)[1:0],
+	 * (ACODEC_ADC_ANA_CON11+0x80)[1:0] and (ACODEC_ADC_ANA_CON11+0xc0)[1:0]
+	 * to 0x3, to enable the ALC module to control the gain of PGA.
+	 */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON11(grp),
+				   RK3308_ADC_ALCL_CON_GAIN_PGAL_MSK |
+				   RK3308_ADC_ALCR_CON_GAIN_PGAR_MSK,
+				   RK3308_ADC_ALCL_CON_GAIN_PGAL_EN |
+				   RK3308_ADC_ALCR_CON_GAIN_PGAR_EN);
+	}
+#endif
+	/*
+	 * 5.Observe the current ALC output gain by reading
+	 * ACODEC_ALC_DIG_CON12[4:0]
+	 */
+
+	/* Do nothing if we don't use AGC */
+
+	return 0;
+}
+
+static int rk3308_codec_alc_disable(struct rk3308_codec_priv *rk3308)
+{
+	int grp;
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/*
+		 * 1. Set ACODEC_ALC_DIG_CON9[6] to 0x0, to disable the ALC
+		 * module, then the ALC output gain will keep to the last value
+		 */
+		regmap_update_bits(rk3308->regmap, RK3308_ALC_L_DIG_CON09(grp),
+				   RK3308_AGC_FUNC_SEL_MSK,
+				   RK3308_AGC_FUNC_SEL_DIS);
+		regmap_update_bits(rk3308->regmap, RK3308_ALC_R_DIG_CON09(grp),
+				   RK3308_AGC_FUNC_SEL_MSK,
+				   RK3308_AGC_FUNC_SEL_DIS);
+	}
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/*
+		 * 2. Set ACODEC_ADC_ANA_CON11[1:0], (ACODEC_ADC_ANA_CON11+0x40)
+		 * [1:0], (ACODEC_ADC_ANA_CON11+0x80)[1:0] and
+		 * (ACODEC_ADC_ANA_CON11+0xc0)[1:0] to 0x0, to disable the ALC
+		 * module to control the gain of PGA.
+		 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON11(grp),
+				   RK3308_ADC_ALCL_CON_GAIN_PGAL_MSK |
+				   RK3308_ADC_ALCR_CON_GAIN_PGAR_MSK,
+				   RK3308_ADC_ALCL_CON_GAIN_PGAL_DIS |
+				   RK3308_ADC_ALCR_CON_GAIN_PGAR_DIS);
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_adc_reinit_mics(struct rk3308_codec_priv *rk3308)
+{
+	int grp;
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/* vendor step 1 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON05(grp),
+				   RK3308_ADC_CH1_ADC_WORK |
+				   RK3308_ADC_CH2_ADC_WORK,
+				   RK3308_ADC_CH1_ADC_INIT |
+				   RK3308_ADC_CH2_ADC_INIT);
+	}
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/* vendor step 2 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON02(grp),
+				   RK3308_ADC_CH1_ALC_WORK |
+				   RK3308_ADC_CH2_ALC_WORK,
+				   RK3308_ADC_CH1_ALC_INIT |
+				   RK3308_ADC_CH2_ALC_INIT);
+	}
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/* vendor step 3 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_MIC_WORK |
+				   RK3308_ADC_CH2_MIC_WORK,
+				   RK3308_ADC_CH1_MIC_INIT |
+				   RK3308_ADC_CH2_MIC_INIT);
+	}
+
+	usleep_range(2000, 2500);	/* estimated value */
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/* vendor step 1 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON05(grp),
+				   RK3308_ADC_CH1_ADC_WORK |
+				   RK3308_ADC_CH2_ADC_WORK,
+				   RK3308_ADC_CH1_ADC_WORK |
+				   RK3308_ADC_CH2_ADC_WORK);
+	}
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/* vendor step 2 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON02(grp),
+				   RK3308_ADC_CH1_ALC_WORK |
+				   RK3308_ADC_CH2_ALC_WORK,
+				   RK3308_ADC_CH1_ALC_WORK |
+				   RK3308_ADC_CH2_ALC_WORK);
+	}
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/* vendor step 3 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_MIC_WORK |
+				   RK3308_ADC_CH2_MIC_WORK,
+				   RK3308_ADC_CH1_MIC_WORK |
+				   RK3308_ADC_CH2_MIC_WORK);
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_adc_ana_enable(struct rk3308_codec_priv *rk3308)
+{
+	unsigned int adc_aif1 = 0, adc_aif2 = 0;
+	unsigned int agc_func_en;
+	int grp = rk3308->adc_cur_grp;
+
+	/*
+	 * 1. Set the ACODEC_ADC_ANA_CON7[7:6] and ACODEC_ADC_ANA_CON7[5:4],
+	 * to select the line-in or microphone as input of ADC
+	 *
+	 * Note1. Please ignore the step1 for enabling ADC3, ADC4, ADC5,
+	 * ADC6, ADC7, and ADC8
+	 */
+	if (rk3308->adc_grp0_using_linein) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON07(0),
+				   RK3308_ADC_CH1_IN_SEL_MSK |
+				   RK3308_ADC_CH2_IN_SEL_MSK,
+				   RK3308_ADC_CH1_IN_LINEIN |
+				   RK3308_ADC_CH2_IN_LINEIN);
+
+		/* Keep other ADCs as MIC-IN */
+		for (grp = 1; grp < ADC_LR_GROUP_MAX; grp++) {
+			regmap_update_bits(rk3308->regmap,
+					   RK3308_ADC_ANA_CON07(grp),
+					   RK3308_ADC_CH1_IN_SEL_MSK |
+					   RK3308_ADC_CH2_IN_SEL_MSK,
+					   RK3308_ADC_CH1_IN_MIC |
+					   RK3308_ADC_CH2_IN_MIC);
+		}
+	} else {
+		for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+			regmap_update_bits(rk3308->regmap,
+					   RK3308_ADC_ANA_CON07(grp),
+					   RK3308_ADC_CH1_IN_SEL_MSK |
+					   RK3308_ADC_CH2_IN_SEL_MSK,
+					   RK3308_ADC_CH1_IN_MIC |
+					   RK3308_ADC_CH2_IN_MIC);
+		}
+	}
+
+	/*
+	 * 2. Set ACODEC_ADC_ANA_CON0[7] and [3] to 0x1, to end the mute station
+	 * of ADC, to enable the MIC module, to enable the reference voltage
+	 * buffer, and to end the initialization of MIC
+	 */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++)
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_MIC_UNMUTE |
+				   RK3308_ADC_CH2_MIC_UNMUTE,
+				   RK3308_ADC_CH1_MIC_UNMUTE |
+				   RK3308_ADC_CH2_MIC_UNMUTE);
+	/*
+	 * 3. Set ACODEC_ADC_ANA_CON6[0] to 0x1, to enable the current source
+	 * of audio
+	 */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON06(grp),
+				   RK3308_ADC_CURRENT_MSK,
+				   RK3308_ADC_CURRENT_EN);
+	}
+
+	/* vendor step 4*/
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_BUF_REF_EN |
+				   RK3308_ADC_CH2_BUF_REF_EN,
+				   RK3308_ADC_CH1_BUF_REF_EN |
+				   RK3308_ADC_CH2_BUF_REF_EN);
+	}
+
+	/* vendor step 5 */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_MIC_EN |
+				   RK3308_ADC_CH2_MIC_EN,
+				   RK3308_ADC_CH1_MIC_EN |
+				   RK3308_ADC_CH2_MIC_EN);
+	}
+
+	/* vendor step 6 */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON02(grp),
+				   RK3308_ADC_CH1_ALC_EN |
+				   RK3308_ADC_CH2_ALC_EN,
+				   RK3308_ADC_CH1_ALC_EN |
+				   RK3308_ADC_CH2_ALC_EN);
+	}
+
+	/* vendor step 7 */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON05(grp),
+				   RK3308_ADC_CH1_CLK_EN |
+				   RK3308_ADC_CH2_CLK_EN,
+				   RK3308_ADC_CH1_CLK_EN |
+				   RK3308_ADC_CH2_CLK_EN);
+	}
+
+	/* vendor step 8 */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON05(grp),
+				   RK3308_ADC_CH1_ADC_EN |
+				   RK3308_ADC_CH2_ADC_EN,
+				   RK3308_ADC_CH1_ADC_EN |
+				   RK3308_ADC_CH2_ADC_EN);
+	}
+
+	/* vendor step 9 */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON05(grp),
+				   RK3308_ADC_CH1_ADC_WORK |
+				   RK3308_ADC_CH2_ADC_WORK,
+				   RK3308_ADC_CH1_ADC_WORK |
+				   RK3308_ADC_CH2_ADC_WORK);
+	}
+
+	/* vendor step 10 */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON02(grp),
+				   RK3308_ADC_CH1_ALC_WORK |
+				   RK3308_ADC_CH2_ALC_WORK,
+				   RK3308_ADC_CH1_ALC_WORK |
+				   RK3308_ADC_CH2_ALC_WORK);
+	}
+
+	/* vendor step 11 */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_MIC_WORK |
+				   RK3308_ADC_CH2_MIC_WORK,
+				   RK3308_ADC_CH1_MIC_WORK |
+				   RK3308_ADC_CH2_MIC_WORK);
+	}
+
+	/* vendor step 12 */
+	adc_aif1 = RK3308_ADC_CH1_MIC_GAIN_0DB;
+	adc_aif2 = RK3308_ADC_CH2_MIC_GAIN_0DB;
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON01(grp),
+				   RK3308_ADC_CH1_MIC_GAIN_MSK |
+				   RK3308_ADC_CH2_MIC_GAIN_MSK,
+				   adc_aif1 | adc_aif2);
+	}
+
+	/* vendor step 13 */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON03(grp),
+				   RK3308_ADC_CH1_ALC_GAIN_MSK,
+				   RK3308_ADC_CH1_ALC_GAIN_0DB);
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON04(grp),
+				   RK3308_ADC_CH2_ALC_GAIN_MSK,
+				   RK3308_ADC_CH2_ALC_GAIN_0DB);
+	}
+
+	/* vendor step 14 */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_read(rk3308->regmap, RK3308_ALC_L_DIG_CON09(grp),
+			    &agc_func_en);
+		if (rk3308->adc_zerocross ||
+		    agc_func_en & RK3308_AGC_FUNC_SEL_EN) {
+			regmap_update_bits(rk3308->regmap,
+					   RK3308_ADC_ANA_CON02(grp),
+					   RK3308_ADC_CH1_ZEROCROSS_DET_EN,
+					   RK3308_ADC_CH1_ZEROCROSS_DET_EN);
+		}
+		regmap_read(rk3308->regmap, RK3308_ALC_R_DIG_CON09(grp),
+			    &agc_func_en);
+		if (rk3308->adc_zerocross ||
+		    agc_func_en & RK3308_AGC_FUNC_SEL_EN) {
+			regmap_update_bits(rk3308->regmap,
+					   RK3308_ADC_ANA_CON02(grp),
+					   RK3308_ADC_CH2_ZEROCROSS_DET_EN,
+					   RK3308_ADC_CH2_ZEROCROSS_DET_EN);
+		}
+	}
+
+	/* vendor step 15, re-init mic */
+	rk3308_codec_adc_reinit_mics(rk3308);
+
+	/* vendor step 16 Begin recording */
+
+	return 0;
+}
+
+static int rk3308_codec_adc_ana_disable(struct rk3308_codec_priv *rk3308)
+{
+	int grp;
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/* vendor step 1 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON02(grp),
+				   RK3308_ADC_CH1_ZEROCROSS_DET_EN |
+				   RK3308_ADC_CH2_ZEROCROSS_DET_EN,
+				   RK3308_ADC_CH1_ZEROCROSS_DET_DIS |
+				   RK3308_ADC_CH2_ZEROCROSS_DET_DIS);
+	}
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/* vendor step 2 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON05(grp),
+				   RK3308_ADC_CH1_ADC_EN |
+				   RK3308_ADC_CH2_ADC_EN,
+				   RK3308_ADC_CH1_ADC_DIS |
+				   RK3308_ADC_CH2_ADC_DIS);
+	}
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/* vendor step 3 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON05(grp),
+				   RK3308_ADC_CH1_CLK_EN |
+				   RK3308_ADC_CH2_CLK_EN,
+				   RK3308_ADC_CH1_CLK_DIS |
+				   RK3308_ADC_CH2_CLK_DIS);
+	}
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/* vendor step 4 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON02(grp),
+				   RK3308_ADC_CH1_ALC_EN |
+				   RK3308_ADC_CH2_ALC_EN,
+				   RK3308_ADC_CH1_ALC_DIS |
+				   RK3308_ADC_CH2_ALC_DIS);
+	}
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/* vendor step 5 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_MIC_EN |
+				   RK3308_ADC_CH2_MIC_EN,
+				   RK3308_ADC_CH1_MIC_DIS |
+				   RK3308_ADC_CH2_MIC_DIS);
+	}
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/* vendor step 6 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_BUF_REF_EN |
+				   RK3308_ADC_CH2_BUF_REF_EN,
+				   RK3308_ADC_CH1_BUF_REF_DIS |
+				   RK3308_ADC_CH2_BUF_REF_DIS);
+	}
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/* vendor step 7 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON06(grp),
+				   RK3308_ADC_CURRENT_MSK,
+				   RK3308_ADC_CURRENT_DIS);
+	}
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/* vendor step 8 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON05(grp),
+				   RK3308_ADC_CH1_ADC_WORK |
+				   RK3308_ADC_CH2_ADC_WORK,
+				   RK3308_ADC_CH1_ADC_INIT |
+				   RK3308_ADC_CH2_ADC_INIT);
+	}
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/* vendor step 9 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON02(grp),
+				   RK3308_ADC_CH1_ALC_WORK |
+				   RK3308_ADC_CH2_ALC_WORK,
+				   RK3308_ADC_CH1_ALC_INIT |
+				   RK3308_ADC_CH2_ALC_INIT);
+	}
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		/* vendor step 10 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_MIC_WORK |
+				   RK3308_ADC_CH2_MIC_WORK,
+				   RK3308_ADC_CH1_MIC_INIT |
+				   RK3308_ADC_CH2_MIC_INIT);
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_open_capture(struct snd_soc_codec *codec)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_codec_get_drvdata(codec);
+	int grp = 0;
+
+	rk3308_codec_alc_enable(rk3308);
+	rk3308_codec_adc_ana_enable(rk3308);
+
+	if (rk3308->adc_grp0_using_linein) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_DIG_CON03(0),
+				   RK3308_ADC_L_CH_BIST_MSK,
+				   RK3308_ADC_L_CH_NORMAL_RIGHT);
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_DIG_CON03(0),
+				   RK3308_ADC_R_CH_BIST_MSK,
+				   RK3308_ADC_R_CH_NORMAL_LEFT);
+	} else {
+		for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+			regmap_update_bits(rk3308->regmap,
+					   RK3308_ADC_DIG_CON03(grp),
+					   RK3308_ADC_L_CH_BIST_MSK,
+					   RK3308_ADC_L_CH_NORMAL_LEFT);
+			regmap_update_bits(rk3308->regmap,
+					   RK3308_ADC_DIG_CON03(grp),
+					   RK3308_ADC_R_CH_BIST_MSK,
+					   RK3308_ADC_R_CH_NORMAL_RIGHT);
+		}
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_close_capture(struct snd_soc_codec *codec)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_codec_get_drvdata(codec);
+
+	rk3308_codec_alc_disable(rk3308);
+	rk3308_codec_adc_ana_disable(rk3308);
+
+	return 0;
+}
+
+static int rk3308_codec_open_playback(struct snd_soc_codec *codec)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_codec_get_drvdata(codec);
+
+	rk3308_codec_dac_enable(rk3308);
+	rk3308_codec_set_dac_path_state(rk3308, PATH_BUSY);
+
+	return 0;
+}
+
+static int rk3308_codec_close_playback(struct snd_soc_codec *codec)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_codec_get_drvdata(codec);
+
+	rk3308_codec_set_dac_path_state(rk3308, PATH_IDLE);
+	rk3308_codec_dac_disable(rk3308);
+
+	return 0;
+}
+
+static int rk3308_pcm_startup(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct rk3308_codec_priv *rk3308 = snd_soc_codec_get_drvdata(codec);
+	int ret = 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		ret = rk3308_codec_open_playback(codec);
+	else
+		ret = rk3308_codec_open_capture(codec);
+
+	regcache_cache_only(rk3308->regmap, false);
+	regcache_sync(rk3308->regmap);
+
+	return ret;
+}
+
+static void rk3308_pcm_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct rk3308_codec_priv *rk3308 = snd_soc_codec_get_drvdata(codec);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		rk3308_codec_close_playback(codec);
+	else
+		rk3308_codec_close_capture(codec);
+
+	regcache_cache_only(rk3308->regmap, false);
+	regcache_sync(rk3308->regmap);
+}
+
+static struct snd_soc_dai_ops rk3308_dai_ops = {
+	.hw_params = rk3308_hw_params,
+	.set_fmt = rk3308_set_dai_fmt,
+	.mute_stream = rk3308_mute_stream,
+	.startup = rk3308_pcm_startup,
+	.shutdown = rk3308_pcm_shutdown,
+};
+
+static struct snd_soc_dai_driver rk3308_dai[] = {
+	{
+		.name = "rk3308-hifi",
+		.id = RK3308_HIFI,
+		.playback = {
+			.stream_name = "HiFi Playback",
+			.channels_min = 2,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = (SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_S20_3LE |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S32_LE),
+		},
+		.capture = {
+			.stream_name = "HiFi Capture",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = (SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_S20_3LE |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S32_LE),
+		},
+		.ops = &rk3308_dai_ops,
+	},
+};
+
+static int rk3308_suspend(struct snd_soc_codec *codec)
+{
+	rk3308_set_bias_level(codec, SND_SOC_BIAS_OFF);
+
+	return 0;
+}
+
+static int rk3308_resume(struct snd_soc_codec *codec)
+{
+	rk3308_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	return 0;
+}
+
+static int rk3308_codec_prepare(struct snd_soc_codec *codec)
+{
+	/* Clear registers for ADC and DAC */
+	rk3308_codec_close_playback(codec);
+	rk3308_codec_close_capture(codec);
+
+	return 0;
+}
+
+static int rk3308_probe(struct snd_soc_codec *codec)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_codec_get_drvdata(codec);
+
+	rk3308_codec_set_dac_path_state(rk3308, PATH_IDLE);
+
+	rk3308_codec_reset(codec);
+	rk3308_codec_power_on(codec);
+
+	/* From vendor recommend */
+	rk3308_codec_micbias_enable(rk3308, RK3308_ADC_MICBIAS_VOLT_0_85);
+
+	rk3308_codec_prepare(codec);
+	rk3308_codec_headset_detect_enable(rk3308);
+
+	regcache_cache_only(rk3308->regmap, false);
+	regcache_sync(rk3308->regmap);
+
+	return 0;
+}
+
+static int rk3308_remove(struct snd_soc_codec *codec)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_codec_get_drvdata(codec);
+
+	rk3308_headphone_ctl(rk3308, 0);
+	rk3308_speaker_ctl(rk3308, 0);
+	rk3308_codec_headset_detect_disable(rk3308);
+	rk3308_codec_power_off(codec);
+	rk3308_codec_micbias_disable(rk3308);
+
+	rk3308_codec_set_dac_path_state(rk3308, PATH_IDLE);
+
+	regcache_cache_only(rk3308->regmap, false);
+	regcache_sync(rk3308->regmap);
+
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_rk3308 = {
+	.probe = rk3308_probe,
+	.remove = rk3308_remove,
+	.suspend = rk3308_suspend,
+	.resume = rk3308_resume,
+	.set_bias_level = rk3308_set_bias_level,
+	.component_driver = {
+		.controls		= rk3308_codec_dapm_controls,
+		.num_controls		= ARRAY_SIZE(rk3308_codec_dapm_controls),
+	}
+};
+
+static const struct reg_default rk3308_codec_reg_defaults[] = {
+	{ RK3308_GLB_CON, 0x07 },
+};
+
+static bool rk3308_codec_write_read_reg(struct device *dev, unsigned int reg)
+{
+	/* All registers can be read / write */
+	return true;
+}
+
+static bool rk3308_codec_volatile_reg(struct device *dev, unsigned int reg)
+{
+	return true;
+}
+
+static void rk3308_codec_hpdetect_work(struct work_struct *work)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(work, struct rk3308_codec_priv, hpdet_work.work);
+	unsigned int val;
+	int need_poll = 0, need_irq = 0;
+	int need_report = 0, report_type = 0;
+	int dac_output = DAC_LINEOUT;
+
+	regmap_read(rk3308->regmap, RK3308_DAC_DIG_CON14, &val);
+	if (!val) {
+		rk3308->hp_plugged = false;
+
+		need_report = 1;
+		need_irq = 1;
+	} else {
+		if (!rk3308->hp_plugged) {
+			rk3308->hp_plugged = true;
+			report_type = SND_JACK_HEADPHONE;
+			need_report = 1;
+		}
+		need_poll = 1;
+	}
+
+	if (need_poll)
+		queue_delayed_work(system_power_efficient_wq,
+				   &rk3308->hpdet_work,
+				   msecs_to_jiffies(HPDET_POLL_MS));
+
+	if (need_report) {
+		if (report_type)
+			dac_output = DAC_HPOUT;
+
+		rk3308_codec_dac_switch(rk3308, dac_output);
+
+		if (rk3308->hpdet_jack)
+			snd_soc_jack_report(rk3308->hpdet_jack,
+					    report_type,
+					    SND_JACK_HEADPHONE);
+	}
+
+	if (need_irq)
+		enable_irq(rk3308->irq);
+}
+
+static irqreturn_t rk3308_codec_hpdet_isr(int irq, void *data)
+{
+	struct rk3308_codec_priv *rk3308 = data;
+
+	/*
+	 * For the high level irq trigger, disable irq and avoid a lot of
+	 * repeated irq handlers entry.
+	 */
+	disable_irq_nosync(rk3308->irq);
+	queue_delayed_work(system_power_efficient_wq,
+			   &rk3308->hpdet_work, msecs_to_jiffies(10));
+
+	return IRQ_HANDLED;
+}
+
+void rk3308_codec_set_jack_detect(struct snd_soc_codec *codec,
+				  struct snd_soc_jack *hpdet_jack)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_codec_get_drvdata(codec);
+
+	rk3308->hpdet_jack = hpdet_jack;
+}
+EXPORT_SYMBOL_GPL(rk3308_codec_set_jack_detect);
+
+static const struct regmap_config rk3308_codec_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = RK3308_DAC_ANA_CON13,
+	.writeable_reg = rk3308_codec_write_read_reg,
+	.readable_reg = rk3308_codec_write_read_reg,
+	.volatile_reg = rk3308_codec_volatile_reg,
+	.reg_defaults = rk3308_codec_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(rk3308_codec_reg_defaults),
+	.cache_type = REGCACHE_FLAT,
+};
+
+static ssize_t adc_ch_show(struct device *dev,
+			   struct device_attribute *attr,
+			   char *buf)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+
+	return sprintf(buf, "adc_cur_grp: %d\n", rk3308->adc_cur_grp);
+}
+
+static ssize_t adc_ch_store(struct device *dev,
+			    struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	unsigned long grp;
+	int ret = kstrtoul(buf, 10, &grp);
+
+	if (ret < 0 || grp > 4) {
+		dev_err(dev, "Invalid LR grp: %ld, ret: %d\n", grp, ret);
+		return -EINVAL;
+	}
+
+	rk3308->adc_cur_grp = grp;
+
+	dev_info(dev, "store grp: %d\n", rk3308->adc_cur_grp);
+
+	return count;
+}
+
+static ssize_t adc_grp0_in_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+
+	return sprintf(buf, "adc ch0 using: %s\n",
+		       rk3308->adc_grp0_using_linein ? "line in" : "mic in");
+}
+
+static ssize_t adc_grp0_in_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	unsigned long using_linein;
+	int ret = kstrtoul(buf, 10, &using_linein);
+
+	if (ret < 0 || using_linein > 1) {
+		dev_err(dev, "Invalid input status: %ld, ret: %d\n",
+			using_linein, ret);
+		return -EINVAL;
+	}
+
+	rk3308->adc_grp0_using_linein = using_linein;
+
+	dev_info(dev, "store using_linein: %d\n",
+		 rk3308->adc_grp0_using_linein);
+
+	return count;
+}
+
+static ssize_t adc_zerocross_show(struct device *dev,
+				  struct device_attribute *attr,
+				  char *buf)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+
+	return sprintf(buf, "adc zerocross: %s\n",
+		       rk3308->adc_zerocross ? "enabled" : "disabled");
+}
+
+static ssize_t adc_zerocross_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	unsigned long zerocross;
+	int ret = kstrtoul(buf, 10, &zerocross);
+
+	if (ret < 0 || zerocross > 1) {
+		dev_err(dev, "Invalid zerocross: %ld, ret: %d\n",
+			zerocross, ret);
+		return -EINVAL;
+	}
+
+	rk3308->adc_zerocross = zerocross;
+
+	dev_info(dev, "store adc zerocross: %d\n", rk3308->adc_zerocross);
+
+	return count;
+}
+
+static ssize_t dac_output_show(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	ssize_t ret = 0;
+
+	switch (rk3308->dac_output) {
+	case DAC_LINEOUT:
+		ret = sprintf(buf, "dac path: %s\n", "line out");
+		break;
+	case DAC_HPOUT:
+		ret = sprintf(buf, "dac path: %s\n", "hp out");
+		break;
+	case DAC_LINEOUT_HPOUT:
+		ret = sprintf(buf, "dac path: %s\n",
+			      "both line out and hp out");
+		break;
+	default:
+		pr_err("Invalid dac path: %d ?\n", rk3308->dac_output);
+		break;
+	}
+
+	return ret;
+}
+
+static ssize_t dac_output_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	unsigned long dac_output;
+	int ret = kstrtoul(buf, 10, &dac_output);
+
+	if (ret < 0) {
+		dev_err(dev, "Invalid input status: %ld, ret: %d\n",
+			dac_output, ret);
+		return -EINVAL;
+	}
+
+	rk3308_codec_dac_switch(rk3308, dac_output);
+
+	dev_info(dev, "Store dac_output: %d\n", rk3308->dac_output);
+
+	return count;
+}
+
+static const struct device_attribute adc_ch_attrs[] = {
+	__ATTR(adc_cur_grp, 0644, adc_ch_show, adc_ch_store),
+	__ATTR(adc_grp0_in, 0644, adc_grp0_in_show, adc_grp0_in_store),
+	__ATTR(adc_zerocross, 0644, adc_zerocross_show, adc_zerocross_store),
+	__ATTR(dac_output, 0644, dac_output_show, dac_output_store),
+};
+
+static void rk3308_codec_device_release(struct device *dev)
+{
+	/* Do nothing */
+}
+
+static int rk3308_codec_sysfs_init(struct platform_device *pdev,
+				   struct rk3308_codec_priv *rk3308)
+{
+	struct device *dev = &rk3308->dev;
+	int i;
+
+	dev->release = rk3308_codec_device_release;
+	dev->parent = &pdev->dev;
+	set_dev_node(dev, dev_to_node(&pdev->dev));
+	dev_set_name(dev, "rk3308-acodec-dev");
+
+	if (device_register(dev)) {
+		dev_err(&pdev->dev,
+			"Register 'rk3308-acodec-dev' failed\n");
+		dev->parent = NULL;
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(adc_ch_attrs); i++) {
+		if (device_create_file(dev, &adc_ch_attrs[i])) {
+			dev_err(&pdev->dev,
+				"Create 'rk3308-acodec-dev' attr failed\n");
+			device_unregister(dev);
+			return -ENOMEM;
+		}
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_DEBUG_FS)
+static int rk3308_codec_debugfs_reg_show(struct seq_file *s, void *v)
+{
+	struct rk3308_codec_priv *rk3308 = s->private;
+	unsigned int i;
+	unsigned int val;
+
+	for (i = RK3308_GLB_CON; i <= RK3308_DAC_ANA_CON13; i += 4) {
+		regmap_read(rk3308->regmap, i, &val);
+		if (!(i % 16))
+			seq_printf(s, "\nR:%04x: ", i);
+		seq_printf(s, "%08x ", val);
+	}
+
+	seq_puts(s, "\n");
+
+	return 0;
+}
+
+static ssize_t rk3308_codec_debugfs_reg_operate(struct file *file,
+						const char __user *buf,
+						size_t count, loff_t *ppos)
+{
+	struct rk3308_codec_priv *rk3308 =
+		((struct seq_file *)file->private_data)->private;
+	unsigned int reg, val;
+	char op;
+	char kbuf[32];
+	int ret;
+
+	if (count >= sizeof(kbuf))
+		return -EINVAL;
+
+	if (copy_from_user(kbuf, buf, count))
+		return -EFAULT;
+	kbuf[count] = '\0';
+
+	ret = sscanf(kbuf, "%c,%x,%x", &op, &reg, &val);
+	if (ret != 3) {
+		pr_err("sscanf failed: %d\n", ret);
+		return -EFAULT;
+	}
+
+	if (op == 'w') {
+		pr_info("Write reg: 0x%04x with val: 0x%08x\n", reg, val);
+		regmap_write(rk3308->regmap, reg, val);
+		regcache_cache_only(rk3308->regmap, false);
+		regcache_sync(rk3308->regmap);
+		pr_info("Read back reg: 0x%04x with val: 0x%08x\n", reg, val);
+	} else if (op == 'r') {
+		regmap_read(rk3308->regmap, reg, &val);
+		pr_info("Read reg: 0x%04x with val: 0x%08x\n", reg, val);
+	} else {
+		pr_err("This is an invalid operation: %c\n", op);
+	}
+
+	return count;
+}
+
+static int rk3308_codec_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file,
+			   rk3308_codec_debugfs_reg_show, inode->i_private);
+}
+
+static const struct file_operations rk3308_codec_reg_debugfs_fops = {
+	.owner = THIS_MODULE,
+	.open = rk3308_codec_debugfs_open,
+	.read = seq_read,
+	.write = rk3308_codec_debugfs_reg_operate,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+#endif /* CONFIG_DEBUG_FS */
+
+static int rk3308_platform_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct rk3308_codec_priv *rk3308;
+	struct resource *res;
+	struct regmap *grf;
+	void __iomem *base;
+	int ret;
+
+	grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+	if (IS_ERR(grf)) {
+		dev_err(&pdev->dev,
+			"Missing 'rockchip,grf' property\n");
+		return PTR_ERR(grf);
+	}
+
+	rk3308 = devm_kzalloc(&pdev->dev, sizeof(*rk3308), GFP_KERNEL);
+	if (!rk3308)
+		return -ENOMEM;
+
+	ret = rk3308_codec_sysfs_init(pdev, rk3308);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Sysfs init failed\n");
+		return ret;
+	}
+
+#if defined(CONFIG_DEBUG_FS)
+	rk3308->dbg_codec = debugfs_create_dir(CODEC_DRV_NAME, NULL);
+	if (IS_ERR(rk3308->dbg_codec))
+		dev_err(&pdev->dev,
+			"Failed to create debugfs dir for rk3308!\n");
+	else
+		debugfs_create_file("reg", 0644, rk3308->dbg_codec,
+				    rk3308, &rk3308_codec_reg_debugfs_fops);
+#endif
+	rk3308->plat_dev = &pdev->dev;
+
+	rk3308->reset = devm_reset_control_get(&pdev->dev, "acodec-reset");
+	if (IS_ERR(rk3308->reset)) {
+		ret = PTR_ERR(rk3308->reset);
+		if (ret != -ENOENT)
+			return ret;
+
+		dev_dbg(&pdev->dev, "No reset control found\n");
+		rk3308->reset = NULL;
+	}
+
+	rk3308->hp_ctl_gpio = devm_gpiod_get_optional(&pdev->dev, "hp-ctl",
+						       GPIOD_OUT_LOW);
+	if (!rk3308->hp_ctl_gpio) {
+		dev_info(&pdev->dev, "Don't need hp-ctl gpio\n");
+	} else if (IS_ERR(rk3308->hp_ctl_gpio)) {
+		ret = PTR_ERR(rk3308->hp_ctl_gpio);
+		dev_err(&pdev->dev, "Unable to claim gpio hp-ctl\n");
+		return ret;
+	}
+
+	rk3308->spk_ctl_gpio = devm_gpiod_get_optional(&pdev->dev, "spk-ctl",
+						       GPIOD_OUT_LOW);
+
+	if (!rk3308->spk_ctl_gpio) {
+		dev_info(&pdev->dev, "Don't need spk-ctl gpio\n");
+	} else if (IS_ERR(rk3308->spk_ctl_gpio)) {
+		ret = PTR_ERR(rk3308->spk_ctl_gpio);
+		dev_err(&pdev->dev, "Unable to claim gpio spk-ctl\n");
+		return ret;
+	}
+
+#if DEBUG_POP_ALWAYS
+	dev_info(&pdev->dev, "Enable all ctl gpios always for debugging pop\n");
+	rk3308_headphone_ctl(rk3308, 1);
+	rk3308_speaker_ctl(rk3308, 1);
+#else
+	dev_info(&pdev->dev, "De-pop as much as possible\n");
+	rk3308_headphone_ctl(rk3308, 0);
+	rk3308_speaker_ctl(rk3308, 0);
+#endif
+
+	rk3308->pclk = devm_clk_get(&pdev->dev, "acodec");
+	if (IS_ERR(rk3308->pclk)) {
+		dev_err(&pdev->dev, "Can't get acodec pclk\n");
+		return PTR_ERR(rk3308->pclk);
+	}
+
+	rk3308->mclk_rx = devm_clk_get(&pdev->dev, "mclk_rx");
+	if (IS_ERR(rk3308->mclk_rx)) {
+		dev_err(&pdev->dev, "Can't get acodec mclk_rx\n");
+		return PTR_ERR(rk3308->mclk_rx);
+	}
+
+	rk3308->mclk_tx = devm_clk_get(&pdev->dev, "mclk_tx");
+	if (IS_ERR(rk3308->mclk_tx)) {
+		dev_err(&pdev->dev, "Can't get acodec mclk_tx\n");
+		return PTR_ERR(rk3308->mclk_tx);
+	}
+
+	ret = clk_prepare_enable(rk3308->pclk);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to enable acodec pclk: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(rk3308->mclk_rx);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to enable i2s mclk_rx: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(rk3308->mclk_tx);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to enable i2s mclk_tx: %d\n", ret);
+		return ret;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base)) {
+		ret = PTR_ERR(base);
+		dev_err(&pdev->dev, "Failed to ioremap resource\n");
+		goto failed;
+	}
+
+	rk3308->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+					       &rk3308_codec_regmap_config);
+	if (IS_ERR(rk3308->regmap)) {
+		ret = PTR_ERR(rk3308->regmap);
+		dev_err(&pdev->dev, "Failed to regmap mmio\n");
+		goto failed;
+	}
+
+	rk3308->irq = platform_get_irq(pdev, 0);
+	if (rk3308->irq < 0) {
+		dev_err(&pdev->dev, "Can not get codec irq\n");
+		goto failed;
+	}
+
+	INIT_DELAYED_WORK(&rk3308->hpdet_work, rk3308_codec_hpdetect_work);
+
+	ret = devm_request_irq(&pdev->dev, rk3308->irq,
+			       rk3308_codec_hpdet_isr,
+			       0,
+			       "acodec-hpdet",
+			       rk3308);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to request IRQ: %d\n", ret);
+		goto failed;
+	}
+
+	rk3308->adc_grp0_using_linein = ADC_GRP0_MICIN;
+	rk3308->dac_output = DAC_LINEOUT;
+	rk3308->adc_zerocross = 1;
+
+	platform_set_drvdata(pdev, rk3308);
+
+	ret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_rk3308,
+				     rk3308_dai, ARRAY_SIZE(rk3308_dai));
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to register codec: %d\n", ret);
+		goto failed;
+	}
+
+	return ret;
+
+failed:
+	clk_disable_unprepare(rk3308->mclk_rx);
+	clk_disable_unprepare(rk3308->mclk_tx);
+	clk_disable_unprepare(rk3308->pclk);
+	device_unregister(&rk3308->dev);
+
+	return ret;
+}
+
+static int rk3308_platform_remove(struct platform_device *pdev)
+{
+	struct rk3308_codec_priv *rk3308 =
+		(struct rk3308_codec_priv *)platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(rk3308->mclk_rx);
+	clk_disable_unprepare(rk3308->mclk_tx);
+	clk_disable_unprepare(rk3308->pclk);
+	snd_soc_unregister_codec(&pdev->dev);
+	device_unregister(&rk3308->dev);
+
+	return 0;
+}
+
+static const struct of_device_id rk3308codec_of_match[] = {
+	{ .compatible = "rockchip,rk3308-codec", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rk3308codec_of_match);
+
+static struct platform_driver rk3308_codec_driver = {
+	.driver = {
+		   .name = CODEC_DRV_NAME,
+		   .of_match_table = of_match_ptr(rk3308codec_of_match),
+	},
+	.probe = rk3308_platform_probe,
+	.remove = rk3308_platform_remove,
+};
+module_platform_driver(rk3308_codec_driver);
+
+MODULE_AUTHOR("Xing Zheng <zhengxing@rock-chips.com>");
+MODULE_DESCRIPTION("ASoC RK3308 Codec Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/codecs/rk3308_codec.h b/sound/soc/codecs/rk3308_codec.h
new file mode 100644
index 000000000000..586400f9905e
--- /dev/null
+++ b/sound/soc/codecs/rk3308_codec.h
@@ -0,0 +1,1024 @@
+/*
+ * rk3308_codec.h -- RK3308 ALSA Soc Audio Driver
+ *
+ * Copyright (c) 2018, Fuzhou Rockchip Electronics Co., Ltd All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __RK3308_CODEC_H__
+#define __RK3308_CODEC_H__
+
+#define ACODEC_RESET_CTL			0x00 /* REG 0x00 */
+
+/* ADC DIGITAL REGISTERS */
+#define ACODEC_ADC_I2S_CTL0			0x04 /* REG 0x01 */
+#define ACODEC_ADC_I2S_CTL1			0x08 /* REG 0x02 */
+#define ACODEC_ADC_BIST_MODE_SEL		0x0c /* REG 0x03 */
+/* Resevred REG 0x04 ~ 0x06 */
+#define ACODEC_ADC_DATA_PATH			0x1c /* REG 0x07 */
+/* Resevred REG 0x08 ~ 0x0f */
+
+/* REG 0x10 ~ 0x1c are used to configure AGC of Left channel (ALC1) */
+#define ACODEC_ADC_PGA_AGC_L_CTL0		0x40 /* REG 0x10 */
+#define ACODEC_ADC_PGA_AGC_L_CTL1		0x44 /* REG 0x11 */
+#define ACODEC_ADC_PGA_AGC_L_CTL2		0x48 /* REG 0x12 */
+#define ACODEC_ADC_PGA_AGC_L_CTL3		0x4c /* REG 0x13 */
+#define ACODEC_ADC_PGA_AGC_L_CTL4		0x50 /* REG 0x14 */
+#define ACODEC_ADC_PGA_AGC_L_LO_MAX		0x54 /* REG 0x15 */
+#define ACODEC_ADC_PGA_AGC_L_HI_MAX		0x58 /* REG 0x16 */
+#define ACODEC_ADC_PGA_AGC_L_LO_MIN		0x5c /* REG 0x17 */
+#define ACODEC_ADC_PGA_AGC_L_HI_MIN		0x60 /* REG 0x18 */
+#define ACODEC_ADC_PGA_AGC_L_CTL5		0x64 /* REG 0x19 */
+/* Resevred REG 0x1a ~ 0x1b */
+#define ACODEC_ADC_AGC_L_RO_GAIN		0x70 /* REG 0x1c */
+
+/* REG 0x20 ~ 0x2c are used to configure AGC of Right channel (ALC2) */
+#define ACODEC_ADC_PGA_AGC_R_CTL0		0x80 /* REG 0x20 */
+#define ACODEC_ADC_PGA_AGC_R_CTL1		0x84 /* REG 0x21 */
+#define ACODEC_ADC_PGA_AGC_R_CTL2		0x88 /* REG 0x22 */
+#define ACODEC_ADC_PGA_AGC_R_CTL3		0x8c /* REG 0x23 */
+#define ACODEC_ADC_PGA_AGC_R_CTL4		0x90 /* REG 0x24 */
+#define ACODEC_ADC_PGA_AGC_R_LO_MAX		0x94 /* REG 0x25 */
+#define ACODEC_ADC_PGA_AGC_R_HI_MAX		0x98 /* REG 0x26 */
+#define ACODEC_ADC_PGA_AGC_R_LO_MIN		0x9c /* REG 0x27 */
+#define ACODEC_ADC_PGA_AGC_R_HI_MIN		0xa0 /* REG 0x28 */
+#define ACODEC_ADC_PGA_AGC_R_CTL5		0xa4 /* REG 0x29 */
+/* Resevred REG 0x2a ~ 0x2b */
+#define ACODEC_ADC_AGC_R_RO_GAIN		0xb0 /* REG 0x2c */
+
+/* DAC DIGITAL REGISTERS */
+#define ACODEC_DAC_I2S_CTL0			0x04 /* REG 0x01 */
+#define ACODEC_DAC_I2S_CTL1			0x08 /* REG 0x02 */
+#define ACODEC_DAC_BIST_MODE_SEL		0x0c /* REG 0x03 */
+#define ACODEC_DAC_DIGITAL_GAIN			0x10 /* REG 0x04 */
+#define ACODEC_DAC_DATA_SEL			0x14 /* REG 0x05 */
+/* Resevred REG 0x06 ~ 0x09 */
+#define ACODEC_DAC_DATA_HI			0x28 /* REG 0x0a */
+#define ACODEC_DAC_DATA_LO			0x2c /* REG 0x0b */
+/* Resevred REG 0x0c */
+#define ACODEC_DAC_HPDET_DELAYTIME		0x34 /* REG 0x0d */
+#define ACODEC_DAC_HPDET_STATUS			0x38 /* REG 0x0e, Read-only */
+/* Resevred REG 0x0f */
+
+/* ADC ANALOG REGISTERS */
+#define ACODEC_ADC_ANA_MIC_CTL			0x00 /* REG 0x00 */
+#define ACODEC_ADC_ANA_MIC_GAIN			0x04 /* REG 0x01 */
+#define ACODEC_ADC_ANA_ALC_CTL			0x08 /* REG 0x02 */
+#define ACODEC_ADC_ANA_ALC_GAIN1		0x0c /* REG 0x03 */
+#define ACODEC_ADC_ANA_ALC_GAIN2		0x10 /* REG 0x04 */
+#define ACODEC_ADC_ANA_CTL0			0x14 /* REG 0x05 */
+#define ACODEC_ADC_ANA_CTL1			0x18 /* REG 0x06 */
+#define ACODEC_ADC_ANA_CTL2			0x1c /* REG 0x07 */
+#define ACODEC_ADC_ANA_CTL3			0x20 /* REG 0x08 */
+/* Resevred REG 0x09 */
+#define ACODEC_ADC_ANA_CTL4			0x28 /* REG 0x0a */
+#define ACODEC_ADC_ANA_ALC_PGA			0x2c /* REG 0x0b */
+/* Resevred REG 0x0c ~ 0x0f */
+
+/* DAC ANALOG REGISTERS */
+#define ACODEC_DAC_ANA_CTL0			0x00 /* REG 0x00 */
+#define ACODEC_DAC_ANA_POP_VOLT			0x04 /* REG 0x01 */
+#define ACODEC_DAC_ANA_CTL1			0x08 /* REG 0x02 */
+#define ACODEC_DAC_ANA_HPOUT			0x0c /* REG 0x03 */
+#define ACODEC_DAC_ANA_LINEOUT			0x10 /* REG 0x04 */
+#define ACODEC_DAC_ANA_L_HPOUT_GAIN		0x14 /* REG 0x05 */
+#define ACODEC_DAC_ANA_R_HPOUT_GAIN		0x18 /* REG 0x06 */
+#define ACODEC_DAC_ANA_DRV_HPOUT		0x1c /* REG 0x07 */
+#define ACODEC_DAC_ANA_DRV_LINEOUT		0x20 /* REG 0x08 */
+/* Resevred REG 0x07 ~ 0x0b */
+#define ACODEC_DAC_ANA_HPMIX_CTL0		0x30 /* REG 0x0c */
+#define ACODEC_DAC_ANA_HPMIX_CTL1		0x34 /* REG 0x0d */
+/* Resevred REG 0x0e ~ 0x0f */
+
+/*
+ * These registers are referenced by codec driver
+ */
+
+#define RK3308_GLB_CON				ACODEC_RESET_CTL
+
+/* ADC DIGITAL REGISTERS */
+
+/*
+ * The ADC group are 0 ~ 3, that control:
+ *
+ * CH0: left_0(ADC1) and right_0(ADC2)
+ * CH1: left_1(ADC3) and right_1(ADC4)
+ * CH2: left_2(ADC5) and right_2(ADC6)
+ * CH3: left_3(ADC7) and right_3(ADC8)
+ */
+#define RK3308_ADC_DIG_OFFSET(ch)		((ch & 0x3) * 0xc0 + 0x0)
+
+#define RK3308_ADC_DIG_CON01(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_I2S_CTL0)
+#define RK3308_ADC_DIG_CON02(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_I2S_CTL1)
+#define RK3308_ADC_DIG_CON03(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_BIST_MODE_SEL)
+#define RK3308_ADC_DIG_CON07(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_DATA_PATH)
+
+#define RK3308_ALC_L_DIG_CON00(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_CTL0)
+#define RK3308_ALC_L_DIG_CON01(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_CTL1)
+#define RK3308_ALC_L_DIG_CON02(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_CTL2)
+#define RK3308_ALC_L_DIG_CON03(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_CTL3)
+#define RK3308_ALC_L_DIG_CON04(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_CTL4)
+#define RK3308_ALC_L_DIG_CON05(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_LO_MAX)
+#define RK3308_ALC_L_DIG_CON06(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_HI_MAX)
+#define RK3308_ALC_L_DIG_CON07(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_LO_MIN)
+#define RK3308_ALC_L_DIG_CON08(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_HI_MIN)
+#define RK3308_ALC_L_DIG_CON09(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_CTL5)
+#define RK3308_ALC_L_DIG_CON12(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_AGC_L_RO_GAIN)
+
+#define RK3308_ALC_R_DIG_CON00(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_CTL0)
+#define RK3308_ALC_R_DIG_CON01(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_CTL1)
+#define RK3308_ALC_R_DIG_CON02(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_CTL2)
+#define RK3308_ALC_R_DIG_CON03(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_CTL3)
+#define RK3308_ALC_R_DIG_CON04(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_CTL4)
+#define RK3308_ALC_R_DIG_CON05(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_LO_MAX)
+#define RK3308_ALC_R_DIG_CON06(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_HI_MAX)
+#define RK3308_ALC_R_DIG_CON07(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_LO_MIN)
+#define RK3308_ALC_R_DIG_CON08(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_HI_MIN)
+#define RK3308_ALC_R_DIG_CON09(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_CTL5)
+#define RK3308_ALC_R_DIG_CON12(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_AGC_R_RO_GAIN)
+
+/* DAC DIGITAL REGISTERS */
+#define RK3308_DAC_DIG_OFFSET			0x300
+
+#define RK3308_DAC_DIG_CON01			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_I2S_CTL0)
+#define RK3308_DAC_DIG_CON02			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_I2S_CTL1)
+#define RK3308_DAC_DIG_CON03			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_BIST_MODE_SEL)
+#define RK3308_DAC_DIG_CON04			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_DIGITAL_GAIN)
+#define RK3308_DAC_DIG_CON05			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_DATA_SEL)
+#define RK3308_DAC_DIG_CON10			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_DATA_HI)
+#define RK3308_DAC_DIG_CON11			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_DATA_LO)
+#define RK3308_DAC_DIG_CON13			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_HPDET_DELAYTIME)
+#define RK3308_DAC_DIG_CON14			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_HPDET_STATUS)
+
+/* ADC ANALOG REGISTERS */
+/*
+ * The ADC group are 0 ~ 3, that control:
+ *
+ * CH0: left_0(ADC1) and right_0(ADC2)
+ * CH1: left_1(ADC3) and right_1(ADC4)
+ * CH2: left_2(ADC5) and right_2(ADC6)
+ * CH3: left_3(ADC7) and right_3(ADC8)
+ */
+#define RK3308_ADC_ANA_OFFSET(ch)		((ch & 0x3) * 0x40 + 0x340)
+
+#define RK3308_ADC_ANA_CON00(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_MIC_CTL)
+#define RK3308_ADC_ANA_CON01(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_MIC_GAIN)
+#define RK3308_ADC_ANA_CON02(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_ALC_CTL)
+#define RK3308_ADC_ANA_CON03(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_ALC_GAIN1)
+#define RK3308_ADC_ANA_CON04(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_ALC_GAIN2)
+#define RK3308_ADC_ANA_CON05(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_CTL0)
+#define RK3308_ADC_ANA_CON06(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_CTL1)
+#define RK3308_ADC_ANA_CON07(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_CTL2)
+#define RK3308_ADC_ANA_CON08(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_CTL3)
+#define RK3308_ADC_ANA_CON10(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_CTL4)
+#define RK3308_ADC_ANA_CON11(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_ALC_PGA)
+
+/* DAC ANALOG REGISTERS */
+#define RK3308_DAC_ANA_OFFSET			0x440
+#define RK3308_DAC_ANA_CON00			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_CTL0)
+#define RK3308_DAC_ANA_CON01			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_POP_VOLT)
+#define RK3308_DAC_ANA_CON02			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_CTL1)
+#define RK3308_DAC_ANA_CON03			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_HPOUT)
+#define RK3308_DAC_ANA_CON04			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_LINEOUT)
+#define RK3308_DAC_ANA_CON05			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_L_HPOUT_GAIN)
+#define RK3308_DAC_ANA_CON06			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_R_HPOUT_GAIN)
+#define RK3308_DAC_ANA_CON07			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_DRV_HPOUT)
+#define RK3308_DAC_ANA_CON08			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_DRV_LINEOUT)
+#define RK3308_DAC_ANA_CON12			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_HPMIX_CTL0)
+#define RK3308_DAC_ANA_CON13			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_HPMIX_CTL1)
+
+/*
+ * These are the bits for registers
+ */
+
+/* RK3308_GLB_CON - REG: 0x0000 */
+#define RK3308_ADC_BIST_WORK			(1 << 7)
+#define RK3308_ADC_BIST_RESET			(0 << 7)
+#define RK3308_DAC_BIST_WORK			(1 << 6)
+#define RK3308_DAC_BIST_RESET			(0 << 6)
+#define RK3308_CODEC_RST_MSK			(0x7 << 0)
+#define RK3308_ADC_DIG_WORK			(1 << 2)
+#define RK3308_ADC_DIG_RESET			(0 << 2)
+#define RK3308_DAC_DIG_WORK			(1 << 1)
+#define RK3308_DAC_DIG_RESET			(0 << 1)
+#define RK3308_SYS_WORK				(1 << 0)
+#define RK3308_SYS_RESET			(0 << 0)
+
+/* RK3308_ADC_DIG_CON01 - REG: 0x0004 */
+#define RK3308_ADC_I2S_LRC_POL_MSK		(1 << 0)
+#define RK3308_ADC_I2S_LRC_POL_REVERSAL		(1 << 0)
+#define RK3308_ADC_I2S_LRC_POL_NORMAL		(0 << 0)
+#define RK3308_ADC_I2S_VALID_LEN_SFT		5
+#define RK3308_ADC_I2S_VALID_LEN_MSK		(0x3 << RK3308_ADC_I2S_VALID_LEN_SFT)
+#define RK3308_ADC_I2S_VALID_LEN_32BITS		(0x3 << RK3308_ADC_I2S_VALID_LEN_SFT)
+#define RK3308_ADC_I2S_VALID_LEN_24BITS		(0x2 << RK3308_ADC_I2S_VALID_LEN_SFT)
+#define RK3308_ADC_I2S_VALID_LEN_20BITS		(0x1 << RK3308_ADC_I2S_VALID_LEN_SFT)
+#define RK3308_ADC_I2S_VALID_LEN_16BITS		(0x0 << RK3308_ADC_I2S_VALID_LEN_SFT)
+#define RK3308_ADC_I2S_MODE_SFT			3
+#define RK3308_ADC_I2S_MODE_MSK			(0x3 << RK3308_ADC_I2S_MODE_SFT)
+#define RK3308_ADC_I2S_MODE_PCM			(0x3 << RK3308_ADC_I2S_MODE_SFT)
+#define RK3308_ADC_I2S_MODE_I2S			(0x2 << RK3308_ADC_I2S_MODE_SFT)
+#define RK3308_ADC_I2S_MODE_LJ			(0x1 << RK3308_ADC_I2S_MODE_SFT)
+#define RK3308_ADC_I2S_MODE_RJ			(0x0 << RK3308_ADC_I2S_MODE_SFT)
+#define RK3308_ADC_I2S_LR_MSK			(1 << 1)
+#define RK3308_ADC_I2S_LR_SWAP			(1 << 1)
+#define RK3308_ADC_I2S_LR_NORMAL		(0 << 1)
+#define RK3308_ADC_I2S_TYPE_MSK			(1 << 0)
+#define RK3308_ADC_I2S_MONO			(1 << 0)
+#define RK3308_ADC_I2S_STEREO			(0 << 0)
+
+/* RK3308_ADC_DIG_CON02 - REG: 0x0008 */
+#define RK3308_ADC_IO_MODE_MSK			(1 << 5)
+#define RK3308_ADC_IO_MODE_MASTER		(1 << 5)
+#define RK3308_ADC_IO_MODE_SLAVE		(0 << 5)
+#define RK3308_ADC_MODE_MSK			(1 << 4)
+#define RK3308_ADC_MODE_MASTER			(1 << 4)
+#define RK3308_ADC_MODE_SLAVE			(0 << 4)
+#define RK3308_ADC_I2S_FRAME_LEN_SFT		2
+#define RK3308_ADC_I2S_FRAME_LEN_MSK		(0x3 << RK3308_ADC_I2S_FRAME_LEN_SFT)
+#define RK3308_ADC_I2S_FRAME_32BITS		(0x3 << RK3308_ADC_I2S_FRAME_LEN_SFT)
+#define RK3308_ADC_I2S_FRAME_24BITS		(0x2 << RK3308_ADC_I2S_FRAME_LEN_SFT)
+#define RK3308_ADC_I2S_FRAME_20BITS		(0x1 << RK3308_ADC_I2S_FRAME_LEN_SFT)
+#define RK3308_ADC_I2S_FRAME_16BITS		(0x0 << RK3308_ADC_I2S_FRAME_LEN_SFT)
+#define RK3308_ADC_I2S_MSK			(0x1 << 1)
+#define RK3308_ADC_I2S_WORK			(0x1 << 1)
+#define RK3308_ADC_I2S_RESET			(0x0 << 1)
+#define RK3308_ADC_I2S_BIT_CLK_POL_MSK		(0x1 << 0)
+#define RK3308_ADC_I2S_BIT_CLK_POL_REVERSAL	(0x1 << 0)
+#define RK3308_ADC_I2S_BIT_CLK_POL_NORMAL	(0x0 << 0)
+
+/* RK3308_ADC_DIG_CON03 - REG: 0x000c */
+#define RK3308_ADC_L_CH_BIST_SFT		2
+#define RK3308_ADC_L_CH_BIST_MSK		(0x3 << RK3308_ADC_L_CH_BIST_SFT)
+#define RK3308_ADC_L_CH_NORMAL_RIGHT		(0x3 << RK3308_ADC_L_CH_BIST_SFT) /* normal mode */
+#define RK3308_ADC_L_CH_BIST_SINE		(0x2 << RK3308_ADC_L_CH_BIST_SFT)
+#define RK3308_ADC_L_CH_BIST_CUBE		(0x1 << RK3308_ADC_L_CH_BIST_SFT)
+#define RK3308_ADC_L_CH_NORMAL_LEFT		(0x0 << RK3308_ADC_L_CH_BIST_SFT) /* normal mode */
+#define RK3308_ADC_R_CH_BIST_SFT		0
+#define RK3308_ADC_R_CH_BIST_MSK		(0x3 << RK3308_ADC_R_CH_BIST_SFT)
+#define RK3308_ADC_R_CH_NORMAL_LEFT		(0x3 << RK3308_ADC_R_CH_BIST_SFT) /* normal mode */
+#define RK3308_ADC_R_CH_BIST_SINE		(0x2 << RK3308_ADC_R_CH_BIST_SFT)
+#define RK3308_ADC_R_CH_BIST_CUBE		(0x1 << RK3308_ADC_R_CH_BIST_SFT)
+#define RK3308_ADC_R_CH_NORMAL_RIGHT		(0x0 << RK3308_ADC_R_CH_BIST_SFT) /* normal mode */
+
+/* RK3308_ADC_DIG_CON07 - REG: 0x001c */
+#define RK3308_ADCL_DATA_SFT			4
+#define RK3308_ADCL_DATA(x)			(x << RK3308_ADCL_DATA_SFT)
+#define RK3308_ADCR_DATA_SFT			2
+#define RK3308_ADCR_DATA(x)			(x << RK3308_ADCR_DATA_SFT)
+#define RK3308_ADCL_DATA_SEL_ADCL		(0x1 << 1)
+#define RK3308_ADCL_DATA_SEL_NORMAL		(0x0 << 1)
+#define RK3308_ADCR_DATA_SEL_ADCR		(0x1 << 0)
+#define RK3308_ADCR_DATA_SEL_NORMAL		(0x0 << 0)
+
+/*
+ * RK3308_ALC_L_DIG_CON00 - REG: 0x0040 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON00 - REG: 0x0080 + ch * 0xc0
+ */
+#define RK3308_GAIN_ATTACK_JACK			(0x1 << 6)
+#define RK3308_GAIN_ATTACK_NORMAL		(0x0 << 6)
+#define RK3308_CTRL_GEN_SFT			4
+#define RK3308_CTRL_GEN_MSK			(0x3 << RK3308_ALC_CTRL_GEN_SFT)
+#define RK3308_CTRL_GEN_JACK3			(0x3 << RK3308_ALC_CTRL_GEN_SFT)
+#define RK3308_CTRL_GEN_JACK2			(0x2 << RK3308_ALC_CTRL_GEN_SFT)
+#define RK3308_CTRL_GEN_JACK1			(0x1 << RK3308_ALC_CTRL_GEN_SFT)
+#define RK3308_CTRL_GEN_NORMAL			(0x0 << RK3308_ALC_CTRL_GEN_SFT)
+#define RK3308_AGC_HOLD_TIME_SFT		0
+#define RK3308_AGC_HOLD_TIME_MSK		(0xf << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_1S			(0xa << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_512MS		(0x9 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_256MS		(0x8 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_128MS		(0x7 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_64MS		(0x6 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_32MS		(0x5 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_16MS		(0x4 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_8MS		(0x3 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_4MS		(0x2 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_2MS		(0x1 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_0MS		(0x0 << RK3308_AGC_HOLD_TIME_SFT)
+
+/*
+ * RK3308_ALC_L_DIG_CON01 - REG: 0x0044 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON01 - REG: 0x0084 + ch * 0xc0
+ */
+#define RK3308_AGC_DECAY_TIME_SFT		4
+/* Normal mode (reg_agc_mode = 0) */
+#define RK3308_AGC_DECAY_NORMAL_MSK		(0xf << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_512MS		(0xa << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_256MS		(0x9 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_128MS		(0x8 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_64MS		(0x7 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_32MS		(0x6 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_16MS		(0x5 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_8MS		(0x4 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_4MS		(0x3 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_2MS		(0x2 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_1MS		(0x1 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_0MS		(0x0 << RK3308_AGC_DECAY_TIME_SFT)
+/* Limiter mode (reg_agc_mode = 1) */
+#define RK3308_AGC_DECAY_LIMITER_MSK		(0xf << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_128MS		(0xa << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_64MS		(0x9 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_32MS		(0x8 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_16MS		(0x7 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_8MS		(0x6 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_4MS		(0x5 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_2MS		(0x4 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_1MS		(0x3 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_500US		(0x2 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_250US		(0x1 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_125US		(0x0 << RK3308_AGC_DECAY_TIME_SFT)
+
+#define RK3308_AGC_ATTACK_TIME_SFT		0
+/* Normal mode (reg_agc_mode = 0) */
+#define RK3308_AGC_ATTACK_NORMAL_MSK		(0xf << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_128MS		(0xa << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_64MS		(0x9 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_32MS		(0x8 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_16MS		(0x7 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_8MS		(0x6 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_4MS		(0x5 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_2MS		(0x4 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_1MS		(0x3 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_500US		(0x2 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_250US		(0x1 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_125US		(0x0 << RK3308_AGC_ATTACK_TIME_SFT)
+/* Limiter mode (reg_agc_mode = 1) */
+#define RK3308_AGC_ATTACK_LIMITER_MSK		(0xf << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_32MS		(0xa << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_16MS		(0x9 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_8MS		(0x8 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_4MS		(0x7 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_2MS		(0x6 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_1MS		(0x5 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_500US		(0x4 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_250US		(0x3 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_125US		(0x2 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_64US		(0x1 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_32US		(0x0 << RK3308_AGC_ATTACK_TIME_SFT)
+
+/*
+ * RK3308_ALC_L_DIG_CON02 - REG: 0x0048 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON02 - REG: 0x0088 + ch * 0xc0
+ */
+#define RK3308_AGC_MODE_LIMITER			(0x1 << 7)
+#define RK3308_AGC_MODE_NORMAL			(0x0 << 7)
+#define RK3308_AGC_ZERO_CRO_EN			(0x1 << 6)
+#define RK3308_AGC_ZERO_CRO_DIS			(0x0 << 6)
+#define RK3308_AGC_AMP_RECOVER_GAIN		(0x1 << 5)
+#define RK3308_AGC_AMP_RECOVER_LVOL		(0x0 << 5)
+#define RK3308_AGC_FAST_DEC_EN			(0x1 << 4)
+#define RK3308_AGC_FAST_DEC_DIS			(0x0 << 4)
+#define RK3308_AGC_NOISE_GATE_EN		(0x1 << 3)
+#define RK3308_AGC_NOISE_GATE_DIS		(0x0 << 3)
+#define RK3308_AGC_NOISE_GATE_THRESH_SFT	0
+#define RK3308_AGC_NOISE_GATE_THRESH_MSK	(0x7 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+#define RK3308_AGC_NOISE_GATE_THRESH_N81DB	(0x7 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+#define RK3308_AGC_NOISE_GATE_THRESH_N75DB	(0x6 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+#define RK3308_AGC_NOISE_GATE_THRESH_N69DB	(0x5 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+#define RK3308_AGC_NOISE_GATE_THRESH_N63DB	(0x4 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+#define RK3308_AGC_NOISE_GATE_THRESH_N57DB	(0x3 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+#define RK3308_AGC_NOISE_GATE_THRESH_N51DB	(0x2 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+#define RK3308_AGC_NOISE_GATE_THRESH_N45DB	(0x1 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+#define RK3308_AGC_NOISE_GATE_THRESH_N39DB	(0x0 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+
+/*
+ * RK3308_ALC_L_DIG_CON03 - REG: 0x004c + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON03 - REG: 0x008c + ch * 0xc0
+ */
+#define RK3308_AGC_PGA_ZERO_CRO_EN		(0x1 << 5)
+#define RK3308_AGC_PGA_ZERO_CRO_DIS		(0x0 << 5)
+#define RK3308_AGC_PGA_GAIN_MAX			0x1f
+#define RK3308_AGC_PGA_GAIN_MIN			0
+#define RK3308_AGC_PGA_GAIN_SFT			0
+#define RK3308_AGC_PGA_GAIN_MSK			(0x1f << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_28_5		(0x1f << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_27		(0x1e << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_25_5		(0x1d << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_24		(0x1c << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_22_5		(0x1b << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_21		(0x1a << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_19_5		(0x19 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_18		(0x18 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_16_5		(0x17 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_15		(0x16 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_13_5		(0x15 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_12		(0x14 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_10_5		(0x13 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_9		(0x12 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_7_5		(0x11 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_6		(0x10 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_4_5		(0x0f << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_3		(0x0e << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_1_5		(0x0d << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_0DB			(0x0c << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_1_5		(0x0b << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_3		(0x0a << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_4_5		(0x09 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_6		(0x08 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_7_5		(0x07 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_9		(0x06 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_10_5		(0x05 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_12		(0x04 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_13_5		(0x03 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_15		(0x02 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_16_5		(0x01 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_18		(0x00 << RK3308_AGC_PGA_GAIN_SFT)
+
+/*
+ * RK3308_ALC_L_DIG_CON04 - REG: 0x0050 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON04 - REG: 0x0090 + ch * 0xc0
+ */
+#define RK3308_AGC_SLOW_CLK_EN			(0x1 << 3)
+#define RK3308_AGC_SLOW_CLK_DIS			(0x0 << 3)
+#define RK3308_AGC_APPROX_RATE_SFT		0
+#define RK3308_AGC_APPROX_RATE_MSK		(0x7 << RK3308_AGC_APPROX_RATE_SFT)
+#define RK3308_AGC_APPROX_RATE_8K		(0x7 << RK3308_AGC_APPROX_RATE_SFT)
+#define RK3308_AGC_APPROX_RATE_12K		(0x6 << RK3308_AGC_APPROX_RATE_SFT)
+#define RK3308_AGC_APPROX_RATE_16K		(0x5 << RK3308_AGC_APPROX_RATE_SFT)
+#define RK3308_AGC_APPROX_RATE_24K		(0x4 << RK3308_AGC_APPROX_RATE_SFT)
+#define RK3308_AGC_APPROX_RATE_32K		(0x3 << RK3308_AGC_APPROX_RATE_SFT)
+#define RK3308_AGC_APPROX_RATE_44_1K		(0x2 << RK3308_AGC_APPROX_RATE_SFT)
+#define RK3308_AGC_APPROX_RATE_48K		(0x1 << RK3308_AGC_APPROX_RATE_SFT)
+#define RK3308_AGC_APPROX_RATE_96K		(0x0 << RK3308_AGC_APPROX_RATE_SFT)
+
+/*
+ * RK3308_ALC_L_DIG_CON05 - REG: 0x0054 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON05 - REG: 0x0094 + ch * 0xc0
+ */
+#define RK3308_AGC_LO_8BITS_AGC_MAX_MSK		0xff
+
+/*
+ * RK3308_ALC_L_DIG_CON06 - REG: 0x0058 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON06 - REG: 0x0098 + ch * 0xc0
+ */
+#define RK3308_AGC_HI_8BITS_AGC_MAX_MSK		0xff
+
+/*
+ * RK3308_ALC_L_DIG_CON07 - REG: 0x005c + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON07 - REG: 0x009c + ch * 0xc0
+ */
+#define RK3308_AGC_LO_8BITS_AGC_MIN_MSK		0xff
+
+/*
+ * RK3308_ALC_L_DIG_CON08 - REG: 0x0060 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON08 - REG: 0x00a0 + ch * 0xc0
+ */
+#define RK3308_AGC_HI_8BITS_AGC_MIN_MSK		0xff
+
+/*
+ * RK3308_ALC_L_DIG_CON09 - REG: 0x0064 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON09 - REG: 0x00a4 + ch * 0xc0
+ */
+#define RK3308_AGC_FUNC_SEL_MSK			(0x1 << 6)
+#define RK3308_AGC_FUNC_SEL_EN			(0x1 << 6)
+#define RK3308_AGC_FUNC_SEL_DIS			(0x0 << 6)
+#define RK3308_AGC_MAX_GAIN_PGA_MAX		0x7
+#define RK3308_AGC_MAX_GAIN_PGA_MIN		0
+#define RK3308_AGC_MAX_GAIN_PGA_SFT		3
+#define RK3308_AGC_MAX_GAIN_PGA_MSK		(0x7 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MAX_GAIN_PGA_PDB_28_5	(0x7 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MAX_GAIN_PGA_PDB_22_5	(0x6 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MAX_GAIN_PGA_PDB_16_5	(0x5 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MAX_GAIN_PGA_PDB_10_5	(0x4 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MAX_GAIN_PGA_PDB_4_5		(0x3 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MAX_GAIN_PGA_NDB_1_5		(0x2 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MAX_GAIN_PGA_NDB_7_5		(0x1 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MAX_GAIN_PGA_NDB_13_5	(0x0 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_MAX		0x7
+#define RK3308_AGC_MIN_GAIN_PGA_MIN		0
+#define RK3308_AGC_MIN_GAIN_PGA_SFT		0
+#define RK3308_AGC_MIN_GAIN_PGA_MSK		(0x7 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_PDB_24		(0x7 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_PDB_18		(0x6 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_PDB_12		(0x5 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_PDB_6		(0x4 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_0DB		(0x3 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_NDB_6		(0x2 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_NDB_12		(0x1 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_NDB_18		(0x0 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+
+/*
+ * RK3308_ALC_L_DIG_CON12 - REG: 0x0068 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON12 - REG: 0x00a8 + ch * 0xc0
+ */
+#define RK3308_AGC_GAIN_MSK			0x1f
+
+/* RK3308_DAC_DIG_CON01 - REG: 0x0304 */
+#define RK3308_DAC_I2S_LRC_POL_MSK		(0x1 << 7)
+#define RK3308_DAC_I2S_LRC_POL_REVERSAL		(0x1 << 7)
+#define RK3308_DAC_I2S_LRC_POL_NORMAL		(0x0 << 7)
+#define RK3308_DAC_I2S_VALID_LEN_SFT		5
+#define RK3308_DAC_I2S_VALID_LEN_MSK		(0x3 << RK3308_DAC_I2S_VALID_LEN_SFT)
+#define RK3308_DAC_I2S_VALID_LEN_32BITS		(0x3 << RK3308_DAC_I2S_VALID_LEN_SFT)
+#define RK3308_DAC_I2S_VALID_LEN_24BITS		(0x2 << RK3308_DAC_I2S_VALID_LEN_SFT)
+#define RK3308_DAC_I2S_VALID_LEN_20BITS		(0x1 << RK3308_DAC_I2S_VALID_LEN_SFT)
+#define RK3308_DAC_I2S_VALID_LEN_16BITS		(0x0 << RK3308_DAC_I2S_VALID_LEN_SFT)
+#define RK3308_DAC_I2S_MODE_SFT			3
+#define RK3308_DAC_I2S_MODE_MSK			(0x3 << RK3308_DAC_I2S_MODE_SFT)
+#define RK3308_DAC_I2S_MODE_PCM			(0x3 << RK3308_DAC_I2S_MODE_SFT)
+#define RK3308_DAC_I2S_MODE_I2S			(0x2 << RK3308_DAC_I2S_MODE_SFT)
+#define RK3308_DAC_I2S_MODE_LJ			(0x1 << RK3308_DAC_I2S_MODE_SFT)
+#define RK3308_DAC_I2S_MODE_RJ			(0x0 << RK3308_DAC_I2S_MODE_SFT)
+#define RK3308_DAC_I2S_LR_MSK			(0x1 << 2)
+#define RK3308_DAC_I2S_LR_SWAP			(0x1 << 2)
+#define RK3308_DAC_I2S_LR_NORMAL		(0x0 << 2)
+
+/* RK3308_DAC_DIG_CON02 - REG: 0x0308 */
+#define RK3308_DAC_IO_MODE_MSK			(0x1 << 5)
+#define RK3308_DAC_IO_MODE_MASTER		(0x1 << 5)
+#define RK3308_DAC_IO_MODE_SLAVE		(0x0 << 5)
+#define RK3308_DAC_MODE_MSK			(0x1 << 4)
+#define RK3308_DAC_MODE_MASTER			(0x1 << 4)
+#define RK3308_DAC_MODE_SLAVE			(0x0 << 4)
+#define RK3308_DAC_I2S_FRAME_LEN_SFT		2
+#define RK3308_DAC_I2S_FRAME_LEN_MSK		(0x3 << RK3308_DAC_I2S_FRAME_LEN_SFT)
+#define RK3308_DAC_I2S_FRAME_32BITS		(0x3 << RK3308_DAC_I2S_FRAME_LEN_SFT)
+#define RK3308_DAC_I2S_FRAME_24BITS		(0x2 << RK3308_DAC_I2S_FRAME_LEN_SFT)
+#define RK3308_DAC_I2S_FRAME_20BITS		(0x1 << RK3308_DAC_I2S_FRAME_LEN_SFT)
+#define RK3308_DAC_I2S_FRAME_16BITS		(0x0 << RK3308_DAC_I2S_FRAME_LEN_SFT)
+#define RK3308_DAC_I2S_MSK			(0x1 << 1)
+#define RK3308_DAC_I2S_WORK			(0x1 << 1)
+#define RK3308_DAC_I2S_RESET			(0x0 << 1)
+#define RK3308_DAC_I2S_BIT_CLK_POL_MSK		(0x1 << 0)
+#define RK3308_DAC_I2S_BIT_CLK_POL_REVERSAL	(0x1 << 0)
+#define RK3308_DAC_I2S_BIT_CLK_POL_NORMAL	(0x0 << 0)
+
+/* RK3308_DAC_DIG_CON03 - REG: 0x030C */
+#define RK3308_DAC_L_CH_BIST_SFT		2
+#define RK3308_DAC_L_CH_BIST_MSK		(0x3 << RK3308_DAC_L_CH_BIST_SFT)
+#define RK3308_DAC_L_CH_BIST_LEFT		(0x3 << RK3308_DAC_L_CH_BIST_SFT) /* normal mode */
+#define RK3308_DAC_L_CH_BIST_CUBE		(0x2 << RK3308_DAC_L_CH_BIST_SFT)
+#define RK3308_DAC_L_CH_BIST_SINE		(0x1 << RK3308_DAC_L_CH_BIST_SFT)
+#define RK3308_DAC_L_CH_BIST_RIGHT		(0x0 << RK3308_DAC_L_CH_BIST_SFT) /* normal mode */
+#define RK3308_DAC_R_CH_BIST_SFT		0
+#define RK3308_DAC_R_CH_BIST_MSK		(0x3 << RK3308_DAC_R_CH_BIST_SFT)
+#define RK3308_DAC_R_CH_BIST_LEFT		(0x3 << RK3308_DAC_R_CH_BIST_SFT) /* normal mode */
+#define RK3308_DAC_R_CH_BIST_CUBE		(0x2 << RK3308_DAC_R_CH_BIST_SFT)
+#define RK3308_DAC_R_CH_BIST_SINE		(0x1 << RK3308_DAC_R_CH_BIST_SFT)
+#define RK3308_DAC_R_CH_BIST_RIGHT		(0x0 << RK3308_DAC_R_CH_BIST_SFT) /* normal mode */
+
+/* RK3308_DAC_DIG_CON04 - REG: 0x0310 */
+#define RK3308_DAC_MODULATOR_GAIN_SFT		4
+#define RK3308_DAC_MODULATOR_GAIN_MSK		(0x7 << RK3308_DAC_MODULATOR_GAIN_SFT)
+#define RK3308_DAC_MODULATOR_GAIN_4_8DB		(0x5 << RK3308_DAC_MODULATOR_GAIN_SFT)
+#define RK3308_DAC_MODULATOR_GAIN_4_2DB		(0x4 << RK3308_DAC_MODULATOR_GAIN_SFT)
+#define RK3308_DAC_MODULATOR_GAIN_3_5DB		(0x3 << RK3308_DAC_MODULATOR_GAIN_SFT)
+#define RK3308_DAC_MODULATOR_GAIN_2_8DB		(0x2 << RK3308_DAC_MODULATOR_GAIN_SFT)
+#define RK3308_DAC_MODULATOR_GAIN_2DB		(0x1 << RK3308_DAC_MODULATOR_GAIN_SFT)
+#define RK3308_DAC_MODULATOR_GAIN_0DB		(0x0 << RK3308_DAC_MODULATOR_GAIN_SFT)
+#define RK3308_DAC_CIC_IF_GAIN_SFT		0
+#define RK3308_DAC_CIC_IF_GAIN_MSK		(0x7 << RK3308_DAC_CIC_IF_GAIN_SFT)
+
+/* RK3308_DAC_DIG_CON05 - REG: 0x0314 */
+#define RK3308_DAC_L_REG_CTL_INDATA		(0x1 << 2)
+#define RK3308_DAC_L_NORMAL_DATA		(0x0 << 2)
+#define RK3308_DAC_R_REG_CTL_INDATA		(0x1 << 1)
+#define RK3308_DAC_R_NORMAL_DATA		(0x0 << 1)
+
+/* RK3308_DAC_DIG_CON10 - REG: 0x0328 */
+#define RK3308_DAC_DATA_HI4(x)			(x & 0xf) /* Need to RK3308_DAC_x_REG_CTL_INDATA */
+
+/* RK3308_DAC_DIG_CON11 - REG: 0x032c */
+#define RK3308_DAC_DATA_LO8(x)			(x & 0xff) /* Need to RK3308_DAC_x_REG_CTL_INDATA */
+
+/* RK3308_ADC_ANA_CON00 - REG: 0x0340 */
+#define RK3308_ADC_CH1_CH2_MIC_ALL_MSK		(0xff << 0)
+#define RK3308_ADC_CH1_CH2_MIC_ALL		0xff
+#define RK3308_ADC_CH2_MIC_UNMUTE		(0x1 << 7)
+#define RK3308_ADC_CH2_MIC_MUTE			(0x0 << 7)
+#define RK3308_ADC_CH2_MIC_WORK			(0x1 << 6)
+#define RK3308_ADC_CH2_MIC_INIT			(0x0 << 6)
+#define RK3308_ADC_CH2_MIC_EN			(0x1 << 5)
+#define RK3308_ADC_CH2_MIC_DIS			(0x0 << 5)
+#define RK3308_ADC_CH2_BUF_REF_EN		(0x1 << 4)
+#define RK3308_ADC_CH2_BUF_REF_DIS		(0x0 << 4)
+#define RK3308_ADC_CH1_MIC_UNMUTE		(0x1 << 3)
+#define RK3308_ADC_CH1_MIC_MUTE			(0x0 << 3)
+#define RK3308_ADC_CH1_MIC_WORK			(0x1 << 2)
+#define RK3308_ADC_CH1_MIC_INIT			(0x0 << 2)
+#define RK3308_ADC_CH1_MIC_EN			(0x1 << 1)
+#define RK3308_ADC_CH1_MIC_DIS			(0x0 << 1)
+#define RK3308_ADC_CH1_BUF_REF_EN		(0x1 << 0)
+#define RK3308_ADC_CH1_BUF_REF_DIS		(0x0 << 0)
+
+/* RK3308_ADC_ANA_CON01 - REG: 0x0344
+ *
+ * The PGA of MIC-INs:
+ * 0x0 - MIC1~MIC8 0dB
+ * 0x1 - MIC1~MIC2 are invalid, MIC3~MIC8 6.6dB
+ * 0x2 - MIC1~MIC2 are invalid, MIC3~MIC8 13dB
+ * 0x3 - MIC1~MIC8 20dB
+ */
+#define RK3308_ADC_CH2_MIC_GAIN_MAX		0x3
+#define RK3308_ADC_CH2_MIC_GAIN_MIN		0
+#define RK3308_ADC_CH2_MIC_GAIN_SFT		4
+#define RK3308_ADC_CH2_MIC_GAIN_MSK		(0x3 << RK3308_ADC_CH2_MIC_GAIN_SFT)
+#define RK3308_ADC_CH2_MIC_GAIN_20DB		(0x3 << RK3308_ADC_CH2_MIC_GAIN_SFT)
+#define RK3308_ADC_3_8_CH2_MIC_GAIN_13DB	(0x2 << RK3308_ADC_CH2_MIC_GAIN_SFT)
+#define RK3308_ADC_3_8_CH2_MIC_GAIN_6_6DB	(0x1 << RK3308_ADC_CH2_MIC_GAIN_SFT)
+#define RK3308_ADC_CH2_MIC_GAIN_0DB		(0x0 << RK3308_ADC_CH2_MIC_GAIN_SFT)
+
+#define RK3308_ADC_CH1_MIC_GAIN_MAX		0x3
+#define RK3308_ADC_CH1_MIC_GAIN_MIN		0
+#define RK3308_ADC_CH1_MIC_GAIN_SFT		0
+#define RK3308_ADC_CH1_MIC_GAIN_MSK		(0x3 << RK3308_ADC_CH1_MIC_GAIN_SFT)
+#define RK3308_ADC_CH1_MIC_GAIN_20DB		(0x3 << RK3308_ADC_CH1_MIC_GAIN_SFT)
+#define RK3308_ADC_3_8_CH1_MIC_GAIN_13DB	(0x2 << RK3308_ADC_CH1_MIC_GAIN_SFT)
+#define RK3308_ADC_3_8_CH1_MIC_GAIN_6_6DB	(0x1 << RK3308_ADC_CH1_MIC_GAIN_SFT)
+#define RK3308_ADC_CH1_MIC_GAIN_0DB		(0x0 << RK3308_ADC_CH1_MIC_GAIN_SFT)
+
+/* RK3308_ADC_ANA_CON02 - REG: 0x0348 */
+#define RK3308_ADC_CH2_ALC_ZC_MSK		(0x7 << 4)
+#define RK3308_ADC_CH2_ZEROCROSS_DET_EN		(0x1 << 6)
+#define RK3308_ADC_CH2_ZEROCROSS_DET_DIS	(0x0 << 6)
+#define RK3308_ADC_CH2_ALC_WORK			(0x1 << 5)
+#define RK3308_ADC_CH2_ALC_INIT			(0x0 << 5)
+#define RK3308_ADC_CH2_ALC_EN			(0x1 << 4)
+#define RK3308_ADC_CH2_ALC_DIS			(0x0 << 4)
+
+#define RK3308_ADC_CH1_ALC_ZC_MSK		(0x7 << 0)
+#define RK3308_ADC_CH1_ZEROCROSS_DET_EN		(0x1 << 2)
+#define RK3308_ADC_CH1_ZEROCROSS_DET_DIS	(0x0 << 2)
+#define RK3308_ADC_CH1_ALC_WORK			(0x1 << 1)
+#define RK3308_ADC_CH1_ALC_INIT			(0x0 << 1)
+#define RK3308_ADC_CH1_ALC_EN			(0x1 << 0)
+#define RK3308_ADC_CH1_ALC_DIS			(0x0 << 0)
+
+/* RK3308_ADC_ANA_CON03 - REG: 0x034c */
+#define RK3308_ADC_CH1_ALC_GAIN_MAX		0x1f
+#define RK3308_ADC_CH1_ALC_GAIN_MIN		0
+#define RK3308_ADC_CH1_ALC_GAIN_SFT		0
+#define RK3308_ADC_CH1_ALC_GAIN_MSK		(0x1f << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_28_5	(0x1f << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_27		(0x1e << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_25_5	(0x1d << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_24		(0x1c << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_22_5	(0x1b << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_21		(0x1a << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_19_5	(0x19 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_18		(0x18 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_16_5	(0x17 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_15		(0x16 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_13_5	(0x15 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_12		(0x14 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_10_5	(0x13 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_9		(0x12 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_7_5		(0x11 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_6		(0x10 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_4_5		(0x0f << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_3		(0x0e << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_1_5		(0x0d << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_0DB		(0x0c << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_1_5		(0x0b << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_3		(0x0a << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_4_5		(0x09 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_6		(0x08 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_7_5		(0x07 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_9		(0x06 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_10_5	(0x05 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_12		(0x04 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_13_5	(0x03 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_15		(0x02 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_16_5	(0x01 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_18		(0x00 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+
+/* RK3308_ADC_ANA_CON04 - REG: 0x0350 */
+#define RK3308_ADC_CH2_ALC_GAIN_MAX		0x1f
+#define RK3308_ADC_CH2_ALC_GAIN_MIN		0
+#define RK3308_ADC_CH2_ALC_GAIN_SFT		0
+#define RK3308_ADC_CH2_ALC_GAIN_MSK		(0x1f << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_28_5	(0x1f << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_27		(0x1e << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_25_5	(0x1d << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_24		(0x1c << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_22_5	(0x1b << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_21		(0x1a << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_19_5	(0x19 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_18		(0x18 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_16_5	(0x17 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_15		(0x16 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_13_5	(0x15 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_12		(0x14 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_10_5	(0x13 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_9		(0x12 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_7_5		(0x11 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_6		(0x10 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_4_5		(0x0f << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_3		(0x0e << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_1_5		(0x0d << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_0DB		(0x0c << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_1_5		(0x0b << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_3		(0x0a << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_4_5		(0x09 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_6		(0x08 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_7_5		(0x07 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_9		(0x06 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_10_5	(0x05 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_12		(0x04 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_13_5	(0x03 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_15		(0x02 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_16_5	(0x01 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_18		(0x00 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+
+/* RK3308_ADC_ANA_CON05 - REG: 0x0354 */
+#define RK3308_ADC_CH2_ADC_CLK_MSK		(0x7 << 4)
+#define RK3308_ADC_CH2_ADC_WORK			(0x1 << 6)
+#define RK3308_ADC_CH2_ADC_INIT			(0x0 << 6)
+#define RK3308_ADC_CH2_ADC_EN			(0x1 << 5)
+#define RK3308_ADC_CH2_ADC_DIS			(0x0 << 5)
+#define RK3308_ADC_CH2_CLK_EN			(0x1 << 4)
+#define RK3308_ADC_CH2_CLK_DIS			(0x0 << 4)
+
+#define RK3308_ADC_CH1_ADC_CLK_MSK		(0x7 << 0)
+#define RK3308_ADC_CH1_ADC_WORK			(0x1 << 2)
+#define RK3308_ADC_CH1_ADC_INIT			(0x0 << 2)
+#define RK3308_ADC_CH1_ADC_EN			(0x1 << 1)
+#define RK3308_ADC_CH1_ADC_DIS			(0x0 << 1)
+#define RK3308_ADC_CH1_CLK_EN			(0x1 << 0)
+#define RK3308_ADC_CH1_CLK_DIS			(0x0 << 0)
+
+/* RK3308_ADC_ANA_CON06 - REG: 0x0358 */
+#define RK3308_ADC_CURRENT_MSK			(0x1 << 0)
+#define RK3308_ADC_CURRENT_EN			(0x1 << 0)
+#define RK3308_ADC_CURRENT_DIS			(0x0 << 0)
+
+/* RK3308_ADC_ANA_CON07 - REG: 0x035c */
+/* Note: The register configuration is only valid for ADC2 */
+#define RK3308_ADC_CH2_IN_SEL_SFT		6
+#define RK3308_ADC_CH2_IN_SEL_MSK		(0x3 << RK3308_ADC_CH2_IN_SEL_SFT)
+#define RK3308_ADC_CH2_IN_LINEIN_MIC		(0x3 << RK3308_ADC_CH2_IN_SEL_SFT)
+#define RK3308_ADC_CH2_IN_LINEIN		(0x2 << RK3308_ADC_CH2_IN_SEL_SFT)
+#define RK3308_ADC_CH2_IN_MIC			(0x1 << RK3308_ADC_CH2_IN_SEL_SFT)
+#define RK3308_ADC_CH2_IN_NONE			(0x0 << RK3308_ADC_CH2_IN_SEL_SFT)
+/* Note: The register configuration is only valid for ADC1 */
+#define RK3308_ADC_CH1_IN_SEL_SFT		4
+#define RK3308_ADC_CH1_IN_SEL_MSK		(0x3 << RK3308_ADC_CH1_IN_SEL_SFT)
+#define RK3308_ADC_CH1_IN_LINEIN_MIC		(0x3 << RK3308_ADC_CH1_IN_SEL_SFT)
+#define RK3308_ADC_CH1_IN_LINEIN		(0x2 << RK3308_ADC_CH1_IN_SEL_SFT)
+#define RK3308_ADC_CH1_IN_MIC			(0x1 << RK3308_ADC_CH1_IN_SEL_SFT)
+#define RK3308_ADC_CH1_IN_NONE			(0x0 << RK3308_ADC_CH1_IN_SEL_SFT)
+
+#define RK3308_ADC_MIC_BIAS_BUF_EN		(0x1 << 3)
+#define RK3308_ADC_MIC_BIAS_BUF_DIS		(0x0 << 3)
+#define RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT	0
+#define RK3308_ADC_LEVEL_RANGE_MICBIAS_MSK	(0x7 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+#define RK3308_ADC_MICBIAS_VOLT_0_85		(0x7 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+#define RK3308_ADC_MICBIAS_VOLT_0_8		(0x6 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+#define RK3308_ADC_MICBIAS_VOLT_0_75		(0x5 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+#define RK3308_ADC_MICBIAS_VOLT_0_7		(0x4 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+#define RK3308_ADC_MICBIAS_VOLT_0_65		(0x3 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+#define RK3308_ADC_MICBIAS_VOLT_0_6		(0x2 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+#define RK3308_ADC_MICBIAS_VOLT_0_55		(0x1 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+#define RK3308_ADC_MICBIAS_VOLT_0_5		(0x0 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+
+/* RK3308_ADC_ANA_CON08 - REG: 0x0360 */
+#define RK3308_ADC_MICBIAS_CURRENT_MSK		(0x1 << 4)
+#define RK3308_ADC_MICBIAS_CURRENT_EN		(0x1 << 4)
+#define RK3308_ADC_MICBIAS_CURRENT_DIS		(0x0 << 4)
+
+/* RK3308_ADC_ANA_CON10 - REG: 0x0368 */
+#define RK3308_ADC_REF_EN			(0x1 << 7)
+#define RK3308_ADC_REF_DIS			(0x0 << 7)
+#define RK3308_ADC_CURRENT_CHARGE_SFT		0
+#define RK3308_ADC_CURRENT_CHARGE_MSK		(0x7f << RK3308_ADC_CURRENT_CHARGE_SFT)
+#define RK3308_ADC_DONT_SEL_ALL			(0x7f << RK3308_ADC_CURRENT_CHARGE_SFT)
+/*
+ * 0: Choose the current I
+ * 1: Don't choose the current I
+ */
+#define RK3308_ADC_SEL_I_1(x)			((x & 0x1) << 6)
+#define RK3308_ADC_SEL_I_2(x)			((x & 0x1) << 5)
+#define RK3308_ADC_SEL_I_4(x)			((x & 0x1) << 4)
+#define RK3308_ADC_SEL_I_8(x)			((x & 0x1) << 3)
+#define RK3308_ADC_SEL_I_16(x)			((x & 0x1) << 2)
+#define RK3308_ADC_SEL_I_32(x)			((x & 0x1) << 1)
+#define RK3308_ADC_SEL_I_64(x)			((x & 0x1) << 0)
+
+/* RK3308_ADC_ANA_CON11 - REG: 0x036c */
+#define RK3308_ADC_ALCR_CON_GAIN_PGAR_MSK	(0x1 << 1)
+#define RK3308_ADC_ALCR_CON_GAIN_PGAR_EN	(0x1 << 1)
+#define RK3308_ADC_ALCR_CON_GAIN_PGAR_DIS	(0x0 << 1)
+#define RK3308_ADC_ALCL_CON_GAIN_PGAL_MSK	(0x1 << 0)
+#define RK3308_ADC_ALCL_CON_GAIN_PGAL_EN	(0x1 << 0)
+#define RK3308_ADC_ALCL_CON_GAIN_PGAL_DIS	(0x0 << 0)
+
+/* RK3308_DAC_ANA_CON00 - REG: 0x0440 */
+#define RK3308_DAC_HEADPHONE_DET_MSK		(0x1 << 1)
+#define RK3308_DAC_HEADPHONE_DET_EN		(0x1 << 1)
+#define RK3308_DAC_HEADPHONE_DET_DIS		(0x0 << 1)
+#define RK3308_DAC_CURRENT_MSK			(0x1 << 0)
+#define RK3308_DAC_CURRENT_EN			(0x1 << 0)
+#define RK3308_DAC_CURRENT_DIS			(0x0 << 0)
+
+/* RK3308_DAC_ANA_CON01 - REG: 0x0444 */
+#define RK3308_DAC_BUF_REF_R_MSK		(0x1 << 6)
+#define RK3308_DAC_BUF_REF_R_EN			(0x1 << 6)
+#define RK3308_DAC_BUF_REF_R_DIS		(0x0 << 6)
+#define RK3308_DAC_POP_SOUND_R_SFT		4
+#define RK3308_DAC_POP_SOUND_R_MSK		(0x3 << RK3308_DAC_POP_SOUND_R_SFT)
+#define RK3308_DAC_POP_SOUND_R_WORK		(0x2 << RK3308_DAC_POP_SOUND_R_SFT)
+#define RK3308_DAC_POP_SOUND_R_INIT		(0x1 << RK3308_DAC_POP_SOUND_R_SFT)
+#define RK3308_DAC_BUF_REF_L_MSK		(0x1 << 2)
+#define RK3308_DAC_BUF_REF_L_EN			(0x1 << 2)
+#define RK3308_DAC_BUF_REF_L_DIS		(0x0 << 2)
+#define RK3308_DAC_POP_SOUND_L_SFT		0
+#define RK3308_DAC_POP_SOUND_L_MSK		(0x3 << RK3308_DAC_POP_SOUND_L_SFT)
+#define RK3308_DAC_POP_SOUND_L_WORK		(0x2 << RK3308_DAC_POP_SOUND_L_SFT)
+#define RK3308_DAC_POP_SOUND_L_INIT		(0x1 << RK3308_DAC_POP_SOUND_L_SFT)
+
+/* RK3308_DAC_ANA_CON02 - REG: 0x0448 */
+#define RK3308_DAC_R_DAC_WORK			(0x1 << 7)
+#define RK3308_DAC_R_DAC_INIT			(0x0 << 7)
+#define RK3308_DAC_R_DAC_EN			(0x1 << 6)
+#define RK3308_DAC_R_DAC_DIS			(0x0 << 6)
+#define RK3308_DAC_R_CLK_EN			(0x1 << 5)
+#define RK3308_DAC_R_CLK_DIS			(0x0 << 5)
+#define RK3308_DAC_R_REF_EN			(0x1 << 4)
+#define RK3308_DAC_R_REF_DIS			(0x0 << 4)
+#define RK3308_DAC_L_DAC_WORK			(0x1 << 3)
+#define RK3308_DAC_L_DAC_INIT			(0x0 << 3)
+#define RK3308_DAC_L_DAC_EN			(0x1 << 2)
+#define RK3308_DAC_L_DAC_DIS			(0x0 << 2)
+#define RK3308_DAC_L_CLK_EN			(0x1 << 1)
+#define RK3308_DAC_L_CLK_DIS			(0x0 << 1)
+#define RK3308_DAC_L_REF_EN			(0x1 << 0)
+#define RK3308_DAC_L_REF_DIS			(0x0 << 0)
+
+/* RK3308_DAC_ANA_CON03 - REG: 0x044c */
+#define RK3308_DAC_R_HPOUT_WORK			(0x1 << 6)
+#define RK3308_DAC_R_HPOUT_INIT			(0x0 << 6)
+#define RK3308_DAC_R_HPOUT_EN			(0x1 << 5)
+#define RK3308_DAC_R_HPOUT_DIS			(0x0 << 5)
+#define RK3308_DAC_R_HPOUT_UNMUTE		(0x1 << 4)
+#define RK3308_DAC_R_HPOUT_MUTE			(0x0 << 4)
+#define RK3308_DAC_L_HPOUT_WORK			(0x1 << 2)
+#define RK3308_DAC_L_HPOUT_INIT			(0x0 << 2)
+#define RK3308_DAC_L_HPOUT_EN			(0x1 << 1)
+#define RK3308_DAC_L_HPOUT_DIS			(0x0 << 1)
+#define RK3308_DAC_L_HPOUT_UNMUTE		(0x1 << 0)
+#define RK3308_DAC_L_HPOUT_MUTE			(0x0 << 0)
+
+/* RK3308_DAC_ANA_CON04 - REG: 0x0450 */
+#define RK3308_DAC_R_LINEOUT_GAIN_MAX		0x3
+#define RK3308_DAC_R_LINEOUT_GAIN_SFT		6
+#define RK3308_DAC_R_LINEOUT_GAIN_MSK		(0x3 << RK3308_DAC_R_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_R_LINEOUT_GAIN_0DB		(0x3 << RK3308_DAC_R_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_R_LINEOUT_GAIN_NDB_1_5	(0x2 << RK3308_DAC_R_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_R_LINEOUT_GAIN_NDB_3		(0x1 << RK3308_DAC_R_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_R_LINEOUT_GAIN_NDB_6		(0x0 << RK3308_DAC_R_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_R_LINEOUT_UNMUTE		(0x1 << 5)
+#define RK3308_DAC_R_LINEOUT_MUTE		(0x0 << 5)
+#define RK3308_DAC_R_LINEOUT_EN			(0x1 << 4)
+#define RK3308_DAC_R_LINEOUT_DIS		(0x0 << 4)
+#define RK3308_DAC_L_LINEOUT_GAIN_MAX		0x3
+#define RK3308_DAC_L_LINEOUT_GAIN_SFT		2
+#define RK3308_DAC_L_LINEOUT_GAIN_MSK		(0x3 << RK3308_DAC_L_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_L_LINEOUT_GAIN_0DB		(0x3 << RK3308_DAC_L_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_L_LINEOUT_GAIN_NDB_1_5	(0x2 << RK3308_DAC_L_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_L_LINEOUT_GAIN_NDB_3		(0x1 << RK3308_DAC_L_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_L_LINEOUT_GAIN_NDB_6		(0x0 << RK3308_DAC_L_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_L_LINEOUT_UNMUTE		(0x1 << 1)
+#define RK3308_DAC_L_LINEOUT_MUTE		(0x0 << 1)
+#define RK3308_DAC_L_LINEOUT_EN			(0x1 << 0)
+#define RK3308_DAC_L_LINEOUT_DIS		(0x0 << 0)
+
+/* RK3308_DAC_ANA_CON05 - REG: 0x0454, step is 1.5db */
+#define RK3308_DAC_L_HPOUT_GAIN_MAX		0x1e
+#define RK3308_DAC_L_HPOUT_GAIN_SFT		0
+#define RK3308_DAC_L_HPOUT_GAIN_MSK		(0x1f << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_PDB_6		(0x1e << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_PDB_4_5		(0x1d << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_PDB_3		(0x1c << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_PDB_1_5		(0x1b << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_0DB		(0x1a << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_1_5		(0x19 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_3		(0x18 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_4_5		(0x17 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_6		(0x16 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_7_5		(0x15 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_9		(0x14 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_10_5	(0x13 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_12		(0x12 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_13_5	(0x11 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_15		(0x10 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_16_5	(0x0f << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_18		(0x0e << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_19_5	(0x0d << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_21		(0x0c << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_22_5	(0x0b << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_24		(0x0a << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_25_5	(0x09 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_27		(0x08 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_28_5	(0x07 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_30		(0x06 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_31_5	(0x05 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_33		(0x04 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_34_5	(0x03 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_36		(0x02 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_37_5	(0x01 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_39		(0x00 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+
+/* RK3308_DAC_ANA_CON06 - REG: 0x0458, step is 1.5db */
+#define RK3308_DAC_R_HPOUT_GAIN_MAX		0x1e
+#define RK3308_DAC_R_HPOUT_GAIN_SFT		0
+#define RK3308_DAC_R_HPOUT_GAIN_MSK		(0x1f << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_PDB_6		(0x1e << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_PDB_4_5		(0x1d << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_PDB_3		(0x1c << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_PDB_1_5		(0x1b << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_0DB		(0x1a << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_1_5		(0x19 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_3		(0x18 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_4_5		(0x17 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_6		(0x16 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_7_5		(0x15 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_9		(0x14 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_10_5	(0x13 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_12		(0x12 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_13_5	(0x11 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_15		(0x10 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_16_5	(0x0f << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_18		(0x0e << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_19_5	(0x0d << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_21		(0x0c << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_22_5	(0x0b << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_24		(0x0a << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_25_5	(0x09 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_27		(0x08 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_28_5	(0x07 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_30		(0x06 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_31_5	(0x05 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_33		(0x04 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_34_5	(0x03 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_36		(0x02 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_37_5	(0x01 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_39		(0x00 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+
+/* RK3308_DAC_ANA_CON07 - REG: 0x045c */
+#define RK3308_DAC_R_HPOUT_DRV_SFT		4
+#define RK3308_DAC_R_HPOUT_DRV_MSK		(0xf << RK3308_DAC_R_HPOUT_DRV_SFT)
+#define RK3308_DAC_L_HPOUT_DRV_SFT		0
+#define RK3308_DAC_L_HPOUT_DRV_MSK		(0xf << RK3308_DAC_L_HPOUT_DRV_SFT)
+
+/* RK3308_DAC_ANA_CON08 - REG: 0x0460 */
+#define RK3308_DAC_R_LINEOUT_DRV_SFT		4
+#define RK3308_DAC_R_LINEOUT_DRV_MSK		(0xf << RK3308_DAC_R_LINEOUT_DRV_SFT)
+#define RK3308_DAC_L_LINEOUT_DRV_SFT		0
+#define RK3308_DAC_L_LINEOUT_DRV_MSK		(0xf << RK3308_DAC_L_LINEOUT_DRV_SFT)
+
+/* RK3308_DAC_ANA_CON12 - REG: 0x0470 */
+#define RK3308_DAC_R_HPMIX_SEL_SFT		6
+#define RK3308_DAC_R_HPMIX_SEL_MSK		(0x3 << RK3308_DAC_R_HPMIX_SEL_SFT)
+#define RK3308_DAC_R_HPMIX_LINEIN_I2S		(0x3 << RK3308_DAC_R_HPMIX_SEL_SFT)
+#define RK3308_DAC_R_HPMIX_LINEIN		(0x2 << RK3308_DAC_R_HPMIX_SEL_SFT)
+#define RK3308_DAC_R_HPMIX_I2S			(0x1 << RK3308_DAC_R_HPMIX_SEL_SFT)
+#define RK3308_DAC_R_HPMIX_NONE			(0x0 << RK3308_DAC_R_HPMIX_SEL_SFT)
+#define RK3308_DAC_R_HPMIX_GAIN_MIN		0x1
+#define RK3308_DAC_R_HPMIX_GAIN_MAX		0x2
+#define RK3308_DAC_R_HPMIX_GAIN_SFT		4
+#define RK3308_DAC_R_HPMIX_GAIN_MSK		(0x3 << RK3308_DAC_R_HPMIX_GAIN_SFT)
+#define RK3308_DAC_R_HPMIX_GAIN_0DB		(0x2 << RK3308_DAC_R_HPMIX_GAIN_SFT)
+#define RK3308_DAC_R_HPMIX_GAIN_NDB_6		(0x1 << RK3308_DAC_R_HPMIX_GAIN_SFT)
+#define RK3308_DAC_L_HPMIX_SEL_SFT		2
+#define RK3308_DAC_L_HPMIX_SEL_MSK		(0x3 << RK3308_DAC_L_HPMIX_SEL_SFT)
+#define RK3308_DAC_L_HPMIX_LINEIN_I2S		(0x3 << RK3308_DAC_L_HPMIX_SEL_SFT)
+#define RK3308_DAC_L_HPMIX_LINEIN		(0x2 << RK3308_DAC_L_HPMIX_SEL_SFT)
+#define RK3308_DAC_L_HPMIX_I2S			(0x1 << RK3308_DAC_L_HPMIX_SEL_SFT)
+#define RK3308_DAC_L_HPMIX_NONE			(0x0 << RK3308_DAC_L_HPMIX_SEL_SFT)
+#define RK3308_DAC_L_HPMIX_GAIN_MIN		0x1
+#define RK3308_DAC_L_HPMIX_GAIN_MAX		0x2
+#define RK3308_DAC_L_HPMIX_GAIN_SFT		0
+#define RK3308_DAC_L_HPMIX_GAIN_MSK		(0x3 << RK3308_DAC_L_HPMIX_GAIN_SFT)
+#define RK3308_DAC_L_HPMIX_GAIN_0DB		(0x2 << RK3308_DAC_L_HPMIX_GAIN_SFT)
+#define RK3308_DAC_L_HPMIX_GAIN_NDB_6		(0x1 << RK3308_DAC_L_HPMIX_GAIN_SFT)
+
+/* RK3308_DAC_ANA_CON13 - REG: 0x0474 */
+#define RK3308_DAC_R_HPMIX_UNMUTE		(0x1 << 6)
+#define RK3308_DAC_R_HPMIX_MUTE			(0x0 << 6)
+#define RK3308_DAC_R_HPMIX_WORK			(0x1 << 5)
+#define RK3308_DAC_R_HPMIX_INIT			(0x0 << 5)
+#define RK3308_DAC_R_HPMIX_EN			(0x1 << 4)
+#define RK3308_DAC_R_HPMIX_DIS			(0x0 << 4)
+#define RK3308_DAC_L_HPMIX_UNMUTE		(0x1 << 2)
+#define RK3308_DAC_L_HPMIX_MUTE			(0x0 << 2)
+#define RK3308_DAC_L_HPMIX_WORK			(0x1 << 1)
+#define RK3308_DAC_L_HPMIX_INIT			(0x0 << 1)
+#define RK3308_DAC_L_HPMIX_EN			(0x1 << 0)
+#define RK3308_DAC_L_HPMIX_DIS			(0x0 << 0)
+
+#define RK3308_HIFI				0x0
+
+#endif /* __RK3308_CODEC_H__ */
diff --git a/sound/soc/codecs/rk3308_codec_provider.h b/sound/soc/codecs/rk3308_codec_provider.h
new file mode 100644
index 000000000000..a447f3a92ff4
--- /dev/null
+++ b/sound/soc/codecs/rk3308_codec_provider.h
@@ -0,0 +1,33 @@
+/*
+ * rk3308_codec_provider.h -- RK3308 ALSA Soc Audio Driver
+ *
+ * Copyright (c) 2018, Fuzhou Rockchip Electronics Co., Ltd All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __RK3308_CODEC_PROVIDER_H__
+#define __RK3308_CODEC_PROVIDER_H__
+
+#ifdef CONFIG_SND_SOC_RK3308
+void rk3308_codec_set_jack_detect(struct snd_soc_codec *codec,
+				  struct snd_soc_jack *hpdet_jack);
+#else
+static inline void rk3308_codec_set_jack_detect(struct snd_soc_codec *codec,
+						struct snd_soc_jack *hpdet_jack)
+{
+}
+#endif
+
+#endif /* __RK3308_CODEC_PROVIDER_H__ */
diff --git a/sound/soc/rockchip/Kconfig b/sound/soc/rockchip/Kconfig
index c783f9a22595..805abad89acb 100644
--- a/sound/soc/rockchip/Kconfig
+++ b/sound/soc/rockchip/Kconfig
@@ -15,6 +15,15 @@ config SND_SOC_ROCKCHIP_I2S
 	  Rockchip I2S device. The device supports upto maximum of
 	  8 channels each for play and record.
 
+config SND_SOC_ROCKCHIP_I2S_TDM
+	tristate "Rockchip I2S/TDM Device Driver"
+	depends on CLKDEV_LOOKUP && SND_SOC_ROCKCHIP
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	  Say Y or M if you want to add support for I2S/TDM driver for
+	  Rockchip I2S/TDM device. The device supports up to maximum of
+	  8 channels each for play and record.
+
 config SND_SOC_ROCKCHIP_SPDIF
 	tristate "Rockchip SPDIF Device Driver"
 	depends on CLKDEV_LOOKUP && SND_SOC_ROCKCHIP
@@ -33,6 +42,13 @@ config SND_SOC_ROCKCHIP_MAX98090
 	  Say Y or M here if you want to add support for SoC audio on Rockchip
 	  boards using the MAX98090 codec, such as Veyron.
 
+config SND_SOC_ROCKCHIP_MULTICODECS
+	tristate "ASoC support for Rockchip multicodecs"
+	depends on SND_SOC_ROCKCHIP && CLKDEV_LOOKUP
+	help
+	  Say Y or M here if you want to add support for SoC audio on Rockchip
+	  boards using multicodecs, such as RK3308 boards.
+
 config SND_SOC_ROCKCHIP_RT5645
 	tristate "ASoC support for Rockchip boards using a RT5645/RT5650 codec"
 	depends on SND_SOC_ROCKCHIP && I2C && GPIOLIB && CLKDEV_LOOKUP
diff --git a/sound/soc/rockchip/Makefile b/sound/soc/rockchip/Makefile
index 84e5c7c700e7..347cdbbc4b45 100644
--- a/sound/soc/rockchip/Makefile
+++ b/sound/soc/rockchip/Makefile
@@ -1,14 +1,18 @@
 # ROCKCHIP Platform Support
 snd-soc-rockchip-i2s-objs := rockchip_i2s.o
+snd-soc-rockchip-i2s-tdm-objs := rockchip_i2s_tdm.o
 snd-soc-rockchip-spdif-objs := rockchip_spdif.o
 
 obj-$(CONFIG_SND_SOC_ROCKCHIP_I2S) += snd-soc-rockchip-i2s.o
+obj-$(CONFIG_SND_SOC_ROCKCHIP_I2S_TDM) += snd-soc-rockchip-i2s-tdm.o
 obj-$(CONFIG_SND_SOC_ROCKCHIP_SPDIF) += snd-soc-rockchip-spdif.o
 
 snd-soc-rockchip-max98090-objs := rockchip_max98090.o
+snd-soc-rockchip-multicodecs-objs := rockchip_multicodecs.o
 snd-soc-rockchip-rt5645-objs := rockchip_rt5645.o
 snd-soc-rk3399-gru-sound-objs := rk3399_gru_sound.o
 
 obj-$(CONFIG_SND_SOC_ROCKCHIP_MAX98090) += snd-soc-rockchip-max98090.o
+obj-$(CONFIG_SND_SOC_ROCKCHIP_MULTICODECS) += snd-soc-rockchip-multicodecs.o
 obj-$(CONFIG_SND_SOC_ROCKCHIP_RT5645) += snd-soc-rockchip-rt5645.o
 obj-$(CONFIG_SND_SOC_RK3399_GRU_SOUND) += snd-soc-rk3399-gru-sound.o
diff --git a/sound/soc/rockchip/rockchip_i2s_tdm.c b/sound/soc/rockchip/rockchip_i2s_tdm.c
new file mode 100644
index 000000000000..01c820ceacac
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_i2s_tdm.c
@@ -0,0 +1,1318 @@
+/* sound/soc/rockchip/rockchip_i2s_tdm.c
+ *
+ * ALSA SoC Audio Layer - Rockchip I2S/TDM Controller driver
+ *
+ * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
+ * Author: Sugar Zhang <sugar.zhang@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/delay.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/spinlock.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "rockchip_i2s_tdm.h"
+
+#define DRV_NAME "rockchip-i2s-tdm"
+
+#define DEFAULT_MCLK_FS				256
+
+struct rk_i2s_soc_data {
+	u32 softrst_offset;
+	int tx_reset_id;
+	int rx_reset_id;
+};
+
+struct rk_i2s_tdm_dev {
+	struct device *dev;
+	struct clk *hclk;
+	struct clk *mclk_tx;
+	struct clk *mclk_rx;
+	/* The mclk_tx_src is parent of mclk_tx */
+	struct clk *mclk_tx_src;
+	/* The mclk_rx_src is parent of mclk_rx */
+	struct clk *mclk_rx_src;
+	/*
+	 * The mclk_root0 and mclk_root1 are root parent and supplies for
+	 * the different FS.
+	 *
+	 * e.g:
+	 * mclk_root0 is VPLL0, used for FS=48000Hz
+	 * mclk_root0 is VPLL1, used for FS=44100Hz
+	 */
+	struct clk *mclk_root0;
+	struct clk *mclk_root1;
+	struct regmap *regmap;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+	struct reset_control *tx_reset;
+	struct reset_control *rx_reset;
+	struct rk_i2s_soc_data *soc_data;
+	void __iomem *cru_base;
+	bool is_master_mode;
+	bool mclk_calibrate;
+	bool tdm_mode;
+	unsigned int mclk_rx_freq;
+	unsigned int mclk_tx_freq;
+	unsigned int bclk_fs;
+	unsigned int clk_trcm;
+	atomic_t refcount;
+	spinlock_t lock; /* xfer lock */
+};
+
+static int i2s_tdm_runtime_suspend(struct device *dev)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+
+	regcache_cache_only(i2s_tdm->regmap, true);
+	if (!IS_ERR(i2s_tdm->mclk_tx))
+		clk_disable_unprepare(i2s_tdm->mclk_tx);
+	if (!IS_ERR(i2s_tdm->mclk_rx))
+		clk_disable_unprepare(i2s_tdm->mclk_rx);
+
+	return 0;
+}
+
+static int i2s_tdm_runtime_resume(struct device *dev)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+	int ret;
+
+	if (!IS_ERR(i2s_tdm->mclk_tx))
+		clk_prepare_enable(i2s_tdm->mclk_tx);
+	if (!IS_ERR(i2s_tdm->mclk_rx))
+		clk_prepare_enable(i2s_tdm->mclk_rx);
+
+	regcache_cache_only(i2s_tdm->regmap, false);
+	regcache_mark_dirty(i2s_tdm->regmap);
+
+	ret = regcache_sync(i2s_tdm->regmap);
+	if (ret) {
+		if (!IS_ERR(i2s_tdm->mclk_tx))
+			clk_disable_unprepare(i2s_tdm->mclk_tx);
+		if (!IS_ERR(i2s_tdm->mclk_rx))
+			clk_disable_unprepare(i2s_tdm->mclk_rx);
+	}
+
+	return ret;
+}
+
+static inline struct rk_i2s_tdm_dev *to_info(struct snd_soc_dai *dai)
+{
+	return snd_soc_dai_get_drvdata(dai);
+}
+
+static void rockchip_snd_xfer_reset_assert(struct rk_i2s_tdm_dev *i2s_tdm,
+					   int tx_bank, int tx_offset,
+					   int rx_bank, int rx_offset)
+{
+	void __iomem *cru_reset, *addr;
+	unsigned long flags;
+	u64 val;
+
+	cru_reset = i2s_tdm->cru_base + i2s_tdm->soc_data->softrst_offset;
+
+	switch (abs(tx_bank - rx_bank)) {
+	case 0:
+		writel(BIT(tx_offset) | BIT(rx_offset) |
+		       (BIT(tx_offset) << 16) | (BIT(rx_offset) << 16),
+		       cru_reset + (tx_bank * 4));
+		break;
+	case 1:
+		if (tx_bank < rx_bank) {
+			val = BIT(rx_offset) | (BIT(rx_offset) << 16);
+			val <<= 32;
+			val |= BIT(tx_offset) | (BIT(tx_offset) << 16);
+			addr = cru_reset + (tx_bank * 4);
+		} else {
+			val = BIT(tx_offset) | (BIT(tx_offset) << 16);
+			val <<= 32;
+			val |= BIT(rx_offset) | (BIT(rx_offset) << 16);
+			addr = cru_reset + (rx_bank * 4);
+		}
+
+		if (IS_ALIGNED((u64)addr, 8)) {
+			writeq(val, addr);
+			break;
+		}
+		/* fall through */
+	default:
+		local_irq_save(flags);
+		writel(BIT(tx_offset) | (BIT(tx_offset) << 16),
+		       cru_reset + (tx_bank * 4));
+		writel(BIT(rx_offset) | (BIT(rx_offset) << 16),
+		       cru_reset + (rx_bank * 4));
+		local_irq_restore(flags);
+		break;
+	}
+}
+
+static void rockchip_snd_xfer_reset_deassert(struct rk_i2s_tdm_dev *i2s_tdm,
+					     int tx_bank, int tx_offset,
+					     int rx_bank, int rx_offset)
+{
+	void __iomem *cru_reset, *addr;
+	unsigned long flags;
+	u64 val;
+
+	cru_reset = i2s_tdm->cru_base + i2s_tdm->soc_data->softrst_offset;
+
+	switch (abs(tx_bank - rx_bank)) {
+	case 0:
+		writel((BIT(tx_offset) << 16) | (BIT(rx_offset) << 16),
+		       cru_reset + (tx_bank * 4));
+		break;
+	case 1:
+		if (tx_bank < rx_bank) {
+			val = (BIT(rx_offset) << 16);
+			val <<= 32;
+			val |= (BIT(tx_offset) << 16);
+			addr = cru_reset + (tx_bank * 4);
+		} else {
+			val = (BIT(tx_offset) << 16);
+			val <<= 32;
+			val |= (BIT(rx_offset) << 16);
+			addr = cru_reset + (rx_bank * 4);
+		}
+
+		if (IS_ALIGNED((u64)addr, 8)) {
+			writeq(val, addr);
+			break;
+		}
+		/* fall through */
+	default:
+		local_irq_save(flags);
+		writel((BIT(tx_offset) << 16),
+		       cru_reset + (tx_bank * 4));
+		writel((BIT(rx_offset) << 16),
+		       cru_reset + (rx_bank * 4));
+		local_irq_restore(flags);
+		break;
+	}
+}
+
+/*
+ * to make sure tx/rx reset at the same time when clk_trcm > 0
+ * if not, will lead lrck is abnormal.
+ */
+static void rockchip_snd_xfer_sync_reset(struct rk_i2s_tdm_dev *i2s_tdm)
+{
+	int tx_id, rx_id;
+	int tx_bank, rx_bank, tx_offset, rx_offset;
+
+	if (!i2s_tdm->cru_base || !i2s_tdm->soc_data)
+		return;
+
+	tx_id = i2s_tdm->soc_data->tx_reset_id;
+	rx_id = i2s_tdm->soc_data->rx_reset_id;
+	if (tx_id < 0 || rx_id < 0) {
+		dev_err(i2s_tdm->dev, "invalid reset id\n");
+		return;
+	}
+
+	tx_bank = tx_id / 16;
+	tx_offset = tx_id % 16;
+	rx_bank = rx_id / 16;
+	rx_offset = rx_id % 16;
+	dev_dbg(i2s_tdm->dev,
+		"tx_bank: %d, rx_bank: %d,tx_offset: %d, rx_offset: %d\n",
+		tx_bank, rx_bank, tx_offset, rx_offset);
+
+	rockchip_snd_xfer_reset_assert(i2s_tdm, tx_bank, tx_offset,
+				       rx_bank, rx_offset);
+
+	udelay(150);
+
+	rockchip_snd_xfer_reset_deassert(i2s_tdm, tx_bank, tx_offset,
+					 rx_bank, rx_offset);
+}
+
+/* only used when clk_trcm > 0 */
+static void rockchip_snd_txrxctrl(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai, int on)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+	unsigned int val = 0;
+	int retry = 10;
+
+	spin_lock(&i2s_tdm->lock);
+	if (on) {
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+					   I2S_DMACR_TDE_ENABLE,
+					   I2S_DMACR_TDE_ENABLE);
+		else
+			regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+					   I2S_DMACR_RDE_ENABLE,
+					   I2S_DMACR_RDE_ENABLE);
+
+		if (atomic_inc_return(&i2s_tdm->refcount) == 1) {
+			rockchip_snd_xfer_sync_reset(i2s_tdm);
+			regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+					   I2S_XFER_TXS_START |
+					   I2S_XFER_RXS_START,
+					   I2S_XFER_TXS_START |
+					   I2S_XFER_RXS_START);
+		}
+	} else {
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+					   I2S_DMACR_TDE_ENABLE,
+					   I2S_DMACR_TDE_DISABLE);
+		else
+			regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+					   I2S_DMACR_RDE_ENABLE,
+					   I2S_DMACR_RDE_DISABLE);
+
+		if (atomic_dec_and_test(&i2s_tdm->refcount)) {
+			regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+					   I2S_XFER_TXS_START |
+					   I2S_XFER_RXS_START,
+					   I2S_XFER_TXS_STOP |
+					   I2S_XFER_RXS_STOP);
+
+			udelay(150);
+			regmap_update_bits(i2s_tdm->regmap, I2S_CLR,
+					   I2S_CLR_TXC | I2S_CLR_RXC,
+					   I2S_CLR_TXC | I2S_CLR_RXC);
+
+			regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+
+			/* Should wait for clear operation to finish */
+			while (val) {
+				regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+				retry--;
+				if (!retry) {
+					dev_info(i2s_tdm->dev, "fail to clear\n");
+					break;
+				}
+			}
+		}
+	}
+	spin_unlock(&i2s_tdm->lock);
+}
+
+static void rockchip_snd_txctrl(struct rk_i2s_tdm_dev *i2s_tdm, int on)
+{
+	unsigned int val = 0;
+	int retry = 10;
+
+	if (on) {
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_TDE_ENABLE, I2S_DMACR_TDE_ENABLE);
+
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_TXS_START,
+				   I2S_XFER_TXS_START);
+	} else {
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_TDE_ENABLE, I2S_DMACR_TDE_DISABLE);
+
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_TXS_START,
+				   I2S_XFER_TXS_STOP);
+
+		udelay(150);
+		regmap_update_bits(i2s_tdm->regmap, I2S_CLR,
+				   I2S_CLR_TXC,
+				   I2S_CLR_TXC);
+
+		regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+
+		/* Should wait for clear operation to finish */
+		while (val) {
+			regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+			retry--;
+			if (!retry) {
+				dev_warn(i2s_tdm->dev, "fail to clear\n");
+				break;
+			}
+		}
+	}
+}
+
+static void rockchip_snd_rxctrl(struct rk_i2s_tdm_dev *i2s_tdm, int on)
+{
+	unsigned int val = 0;
+	int retry = 10;
+
+	if (on) {
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_RDE_ENABLE, I2S_DMACR_RDE_ENABLE);
+
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_RXS_START,
+				   I2S_XFER_RXS_START);
+	} else {
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_RDE_ENABLE, I2S_DMACR_RDE_DISABLE);
+
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_RXS_START,
+				   I2S_XFER_RXS_STOP);
+
+		udelay(150);
+		regmap_update_bits(i2s_tdm->regmap, I2S_CLR,
+				   I2S_CLR_RXC,
+				   I2S_CLR_RXC);
+
+		regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+
+		/* Should wait for clear operation to finish */
+		while (val) {
+			regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+			retry--;
+			if (!retry) {
+				dev_warn(i2s_tdm->dev, "fail to clear\n");
+				break;
+			}
+		}
+	}
+}
+
+static int rockchip_i2s_tdm_set_fmt(struct snd_soc_dai *cpu_dai,
+				    unsigned int fmt)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
+	unsigned int mask = 0, val = 0, tdm_val = 0;
+	int ret = 0;
+	bool is_tdm = i2s_tdm->tdm_mode;
+
+	pm_runtime_get_sync(cpu_dai->dev);
+	mask = I2S_CKR_MSS_MASK;
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		/* Set source clock in Master mode */
+		val = I2S_CKR_MSS_MASTER;
+		i2s_tdm->is_master_mode = true;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		val = I2S_CKR_MSS_SLAVE;
+		i2s_tdm->is_master_mode = false;
+		break;
+	default:
+		ret = -EINVAL;
+		goto err_pm_put;
+	}
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
+
+	mask = I2S_CKR_CKP_MASK;
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		val = I2S_CKR_CKP_NEG;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		val = I2S_CKR_CKP_POS;
+		break;
+	default:
+		ret = -EINVAL;
+		goto err_pm_put;
+	}
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
+
+	mask = I2S_TXCR_IBM_MASK | I2S_TXCR_TFS_MASK | I2S_TXCR_PBM_MASK;
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_RIGHT_J:
+		val = I2S_TXCR_IBM_RSJM;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		val = I2S_TXCR_IBM_LSJM;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		val = I2S_TXCR_IBM_NORMAL;
+		break;
+	case SND_SOC_DAIFMT_DSP_A: /* PCM no delay mode */
+		val = I2S_TXCR_TFS_PCM;
+		break;
+	case SND_SOC_DAIFMT_DSP_B: /* PCM delay 1 mode */
+		val = I2S_TXCR_TFS_PCM | I2S_TXCR_PBM_MODE(1);
+		break;
+	default:
+		ret = -EINVAL;
+		goto err_pm_put;
+	}
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
+
+	mask = I2S_RXCR_IBM_MASK | I2S_RXCR_TFS_MASK | I2S_RXCR_PBM_MASK;
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_RIGHT_J:
+		val = I2S_RXCR_IBM_RSJM;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		val = I2S_RXCR_IBM_LSJM;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		val = I2S_RXCR_IBM_NORMAL;
+		break;
+	case SND_SOC_DAIFMT_DSP_A: /* PCM no delay mode */
+		val = I2S_RXCR_TFS_PCM;
+		break;
+	case SND_SOC_DAIFMT_DSP_B: /* PCM delay 1 mode */
+		val = I2S_RXCR_TFS_PCM | I2S_RXCR_PBM_MODE(1);
+		break;
+	default:
+		ret = -EINVAL;
+		goto err_pm_put;
+	}
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
+
+	if (is_tdm) {
+		switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SND_SOC_DAIFMT_RIGHT_J:
+			val = I2S_TXCR_TFS_TDM_I2S;
+			tdm_val = TDM_SHIFT_CTRL(2);
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			val = I2S_TXCR_TFS_TDM_I2S;
+			tdm_val = TDM_SHIFT_CTRL(1);
+			break;
+		case SND_SOC_DAIFMT_I2S:
+			val = I2S_TXCR_TFS_TDM_I2S;
+			tdm_val = TDM_SHIFT_CTRL(0);
+			break;
+		case SND_SOC_DAIFMT_DSP_A:
+			val = I2S_TXCR_TFS_TDM_PCM;
+			tdm_val = TDM_SHIFT_CTRL(0);
+			break;
+		case SND_SOC_DAIFMT_DSP_B:
+			val = I2S_TXCR_TFS_TDM_PCM;
+			tdm_val = TDM_SHIFT_CTRL(2);
+			break;
+		default:
+			ret = -EINVAL;
+			goto err_pm_put;
+		}
+
+		tdm_val |= TDM_FSYNC_WIDTH_SEL1(1);
+		tdm_val |= TDM_FSYNC_WIDTH_ONE_FRAME;
+
+		mask = I2S_TXCR_TFS_MASK;
+		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
+		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
+
+		mask = TDM_FSYNC_WIDTH_SEL1_MSK | TDM_FSYNC_WIDTH_SEL0_MSK |
+		       TDM_SHIFT_CTRL_MSK;
+		regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
+				   mask, tdm_val);
+		regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
+				   mask, tdm_val);
+	}
+
+err_pm_put:
+	pm_runtime_put(cpu_dai->dev);
+
+	return ret;
+}
+
+static void rockchip_i2s_tdm_xfer_pause(struct snd_pcm_substream *substream,
+					struct rk_i2s_tdm_dev *i2s_tdm)
+{
+	int stream;
+	unsigned int val = 0;
+	int retry = 10;
+
+	stream = SNDRV_PCM_STREAM_LAST - substream->stream;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_TDE_ENABLE,
+				   I2S_DMACR_TDE_DISABLE);
+	else
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_RDE_ENABLE,
+				   I2S_DMACR_RDE_DISABLE);
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+			   I2S_XFER_TXS_START |
+			   I2S_XFER_RXS_START,
+			   I2S_XFER_TXS_STOP |
+			   I2S_XFER_RXS_STOP);
+
+	udelay(150);
+	regmap_update_bits(i2s_tdm->regmap, I2S_CLR,
+			   I2S_CLR_TXC | I2S_CLR_RXC,
+			   I2S_CLR_TXC | I2S_CLR_RXC);
+
+	regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+
+	/* Should wait for clear operation to finish */
+	while (val) {
+		regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+		retry--;
+		if (!retry) {
+			dev_info(i2s_tdm->dev, "fail to clear\n");
+			break;
+		}
+	}
+}
+
+static void rockchip_i2s_tdm_xfer_resume(struct snd_pcm_substream *substream,
+					 struct rk_i2s_tdm_dev *i2s_tdm)
+{
+	int stream;
+
+	stream = SNDRV_PCM_STREAM_LAST - substream->stream;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_TDE_ENABLE,
+				   I2S_DMACR_TDE_ENABLE);
+	else
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_RDE_ENABLE,
+				   I2S_DMACR_RDE_ENABLE);
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+			   I2S_XFER_TXS_START |
+			   I2S_XFER_RXS_START,
+			   I2S_XFER_TXS_START |
+			   I2S_XFER_RXS_START);
+}
+
+static int rockchip_i2s_tdm_calibrate_mclk(struct rk_i2s_tdm_dev *i2s_tdm,
+					   struct snd_pcm_substream *substream,
+					   unsigned int lrck_freq)
+{
+	struct clk *mclk_root;
+	struct clk *mclk_parent;
+	/* It's 256 times higher than a high sample rate */
+	unsigned int mclk_parent_freq;
+	int ret;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		mclk_parent = i2s_tdm->mclk_tx_src;
+	else
+		mclk_parent = i2s_tdm->mclk_rx_src;
+
+	switch (lrck_freq) {
+	case 8000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+	case 192000:
+		mclk_root = i2s_tdm->mclk_root0;
+		mclk_parent_freq = DEFAULT_MCLK_FS * 192000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		mclk_root = i2s_tdm->mclk_root1;
+		mclk_parent_freq = DEFAULT_MCLK_FS * 176400;
+		break;
+	default:
+		dev_err(i2s_tdm->dev, "Invalid LRCK freq: %u Hz\n",
+			lrck_freq);
+		return -EINVAL;
+	}
+
+	ret = clk_set_parent(mclk_parent, mclk_root);
+	if (ret < 0) {
+		dev_err(i2s_tdm->dev, "parent: %s set root: %s failed: %d\n",
+			__clk_get_name(mclk_parent),
+			__clk_get_name(mclk_root),
+			ret);
+		goto out;
+	}
+
+	ret = clk_set_rate(mclk_parent, mclk_parent_freq);
+	if (ret < 0) {
+		dev_err(i2s_tdm->dev, "parent: %s set freq: %d failed: %d\n",
+			__clk_get_name(mclk_parent),
+			mclk_parent_freq,
+			ret);
+		goto out;
+	}
+
+out:
+	return ret;
+}
+
+static int rockchip_i2s_tdm_set_mclk(struct rk_i2s_tdm_dev *i2s_tdm,
+				     struct snd_pcm_substream *substream,
+				     struct clk **mclk)
+{
+	unsigned int mclk_freq;
+	int ret;
+
+	if (i2s_tdm->clk_trcm) {
+		if (i2s_tdm->mclk_tx_freq != i2s_tdm->mclk_rx_freq) {
+			dev_err(i2s_tdm->dev,
+				"clk_trcm, tx: %d and rx: %d should be same\n",
+				i2s_tdm->mclk_tx_freq,
+				i2s_tdm->mclk_rx_freq);
+			ret = -EINVAL;
+			goto err;
+		}
+
+		ret = clk_set_rate(i2s_tdm->mclk_tx, i2s_tdm->mclk_tx_freq);
+		if (ret < 0) {
+			dev_err(i2s_tdm->dev,
+				"Set mclk_tx: %s freq: %d failed: %d\n",
+				__clk_get_name(i2s_tdm->mclk_tx),
+				i2s_tdm->mclk_tx_freq, ret);
+			goto err;
+		}
+
+		ret = clk_set_rate(i2s_tdm->mclk_rx, i2s_tdm->mclk_rx_freq);
+		if (ret < 0) {
+			dev_err(i2s_tdm->dev,
+				"Set mclk_rx: %s freq: %d failed: %d\n",
+				__clk_get_name(i2s_tdm->mclk_rx),
+				i2s_tdm->mclk_rx_freq, ret);
+			goto err;
+		}
+
+		/* Using mclk_rx is ok. */
+		*mclk = i2s_tdm->mclk_tx;
+	} else {
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			*mclk = i2s_tdm->mclk_tx;
+			mclk_freq = i2s_tdm->mclk_tx_freq;
+		} else {
+			*mclk = i2s_tdm->mclk_rx;
+			mclk_freq = i2s_tdm->mclk_rx_freq;
+		}
+
+		ret = clk_set_rate(*mclk, mclk_freq);
+		if (ret < 0) {
+			dev_err(i2s_tdm->dev, "Set mclk_%s: %s freq: %d failed: %d\n",
+				substream->stream ? "rx" : "tx",
+				__clk_get_name(*mclk), mclk_freq, ret);
+			goto err;
+		}
+	}
+
+	return 0;
+
+err:
+	return ret;
+}
+
+static int rockchip_i2s_tdm_hw_params(struct snd_pcm_substream *substream,
+				      struct snd_pcm_hw_params *params,
+				      struct snd_soc_dai *dai)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+	struct clk *mclk;
+	int ret = 0;
+	unsigned int val = 0;
+	unsigned int mclk_rate, bclk_rate, div_bclk, div_lrck;
+
+	if (i2s_tdm->mclk_calibrate)
+		rockchip_i2s_tdm_calibrate_mclk(i2s_tdm, substream,
+						params_rate(params));
+
+	ret = rockchip_i2s_tdm_set_mclk(i2s_tdm, substream, &mclk);
+	if (ret)
+		return ret;
+
+	if (i2s_tdm->clk_trcm) {
+		spin_lock(&i2s_tdm->lock);
+		if (atomic_read(&i2s_tdm->refcount))
+			rockchip_i2s_tdm_xfer_pause(substream, i2s_tdm);
+	}
+
+	if (i2s_tdm->is_master_mode) {
+		mclk_rate = clk_get_rate(mclk);
+		bclk_rate = i2s_tdm->bclk_fs * params_rate(params);
+		if (!bclk_rate) {
+			ret = -EINVAL;
+			goto err;
+		}
+		div_bclk = DIV_ROUND_CLOSEST(mclk_rate, bclk_rate);
+		div_lrck = bclk_rate / params_rate(params);
+		if (i2s_tdm->clk_trcm) {
+			regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+					   I2S_CLKDIV_TXM_MASK | I2S_CLKDIV_RXM_MASK,
+					   I2S_CLKDIV_TXM(div_bclk) | I2S_CLKDIV_RXM(div_bclk));
+			regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+					   I2S_CKR_TSD_MASK | I2S_CKR_RSD_MASK,
+					   I2S_CKR_TSD(div_lrck) | I2S_CKR_RSD(div_lrck));
+		} else if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+					   I2S_CLKDIV_TXM_MASK,
+					   I2S_CLKDIV_TXM(div_bclk));
+			regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+					   I2S_CKR_TSD_MASK,
+					   I2S_CKR_TSD(div_lrck));
+		} else {
+			regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+					   I2S_CLKDIV_RXM_MASK,
+					   I2S_CLKDIV_RXM(div_bclk));
+			regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+					   I2S_CKR_RSD_MASK,
+					   I2S_CKR_RSD(div_lrck));
+		}
+	}
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
+		val |= I2S_TXCR_VDW(8);
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		val |= I2S_TXCR_VDW(16);
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		val |= I2S_TXCR_VDW(20);
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		val |= I2S_TXCR_VDW(24);
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		val |= I2S_TXCR_VDW(32);
+		break;
+	default:
+		ret = -EINVAL;
+		goto err;
+	}
+
+	switch (params_channels(params)) {
+	case 8:
+		val |= I2S_CHN_8;
+		break;
+	case 6:
+		val |= I2S_CHN_6;
+		break;
+	case 4:
+		val |= I2S_CHN_4;
+		break;
+	case 2:
+		val |= I2S_CHN_2;
+		break;
+	default:
+		dev_err(i2s_tdm->dev, "invalid channel: %d\n",
+			params_channels(params));
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
+				   I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,
+				   val);
+	else
+		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
+				   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
+				   val);
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_TDL_MASK,
+			   I2S_DMACR_TDL(16));
+	regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_RDL_MASK,
+			   I2S_DMACR_RDL(16));
+
+	if (i2s_tdm->clk_trcm) {
+		if (atomic_read(&i2s_tdm->refcount))
+			rockchip_i2s_tdm_xfer_resume(substream, i2s_tdm);
+		spin_unlock(&i2s_tdm->lock);
+	}
+
+	return 0;
+
+err:
+	if (i2s_tdm->clk_trcm)
+		spin_unlock(&i2s_tdm->lock);
+	return ret;
+}
+
+static int rockchip_i2s_tdm_trigger(struct snd_pcm_substream *substream,
+				    int cmd, struct snd_soc_dai *dai)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (i2s_tdm->clk_trcm)
+			rockchip_snd_txrxctrl(substream, dai, 1);
+		else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			rockchip_snd_rxctrl(i2s_tdm, 1);
+		else
+			rockchip_snd_txctrl(i2s_tdm, 1);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (i2s_tdm->clk_trcm)
+			rockchip_snd_txrxctrl(substream, dai, 0);
+		else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			rockchip_snd_rxctrl(i2s_tdm, 0);
+		else
+			rockchip_snd_txctrl(i2s_tdm, 0);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int rockchip_i2s_tdm_set_sysclk(struct snd_soc_dai *cpu_dai, int stream,
+				       unsigned int freq, int dir)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
+
+	/* Put set mclk rate into rockchip_i2s_tdm_set_mclk() */
+	if (i2s_tdm->clk_trcm) {
+		i2s_tdm->mclk_tx_freq = freq;
+		i2s_tdm->mclk_rx_freq = freq;
+	} else {
+		if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+			i2s_tdm->mclk_tx_freq = freq;
+		else
+			i2s_tdm->mclk_rx_freq = freq;
+	}
+
+	dev_dbg(i2s_tdm->dev, "The target mclk_%s freq is: %d\n",
+		stream ? "rx" : "tx", freq);
+
+	return 0;
+}
+
+static int rockchip_i2s_tdm_dai_probe(struct snd_soc_dai *dai)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+
+	dai->capture_dma_data = &i2s_tdm->capture_dma_data;
+	dai->playback_dma_data = &i2s_tdm->playback_dma_data;
+
+	return 0;
+}
+
+static int rockchip_dai_tdm_slot(struct snd_soc_dai *dai,
+				 unsigned int tx_mask, unsigned int rx_mask,
+				 int slots, int slot_width)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+	unsigned int mask, val;
+
+	i2s_tdm->tdm_mode = true;
+	i2s_tdm->bclk_fs = slots * slot_width;
+	mask = TDM_SLOT_BIT_WIDTH_MSK | TDM_FRAME_WIDTH_MSK;
+	val = TDM_SLOT_BIT_WIDTH(slot_width) |
+	      TDM_FRAME_WIDTH(slots * slot_width);
+	regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
+			   mask, val);
+	regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
+			   mask, val);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops rockchip_i2s_tdm_dai_ops = {
+	.hw_params = rockchip_i2s_tdm_hw_params,
+	.set_sysclk = rockchip_i2s_tdm_set_sysclk,
+	.set_fmt = rockchip_i2s_tdm_set_fmt,
+	.set_tdm_slot = rockchip_dai_tdm_slot,
+	.trigger = rockchip_i2s_tdm_trigger,
+};
+
+static const struct snd_soc_component_driver rockchip_i2s_tdm_component = {
+	.name = DRV_NAME,
+};
+
+static bool rockchip_i2s_tdm_wr_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case I2S_TXCR:
+	case I2S_RXCR:
+	case I2S_CKR:
+	case I2S_DMACR:
+	case I2S_INTCR:
+	case I2S_XFER:
+	case I2S_CLR:
+	case I2S_TXDR:
+	case I2S_TDM_TXCR:
+	case I2S_TDM_RXCR:
+	case I2S_CLKDIV:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rockchip_i2s_tdm_rd_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case I2S_TXCR:
+	case I2S_RXCR:
+	case I2S_CKR:
+	case I2S_DMACR:
+	case I2S_INTCR:
+	case I2S_XFER:
+	case I2S_CLR:
+	case I2S_RXDR:
+	case I2S_FIFOLR:
+	case I2S_INTSR:
+	case I2S_TDM_TXCR:
+	case I2S_TDM_RXCR:
+	case I2S_CLKDIV:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rockchip_i2s_tdm_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case I2S_INTSR:
+	case I2S_CLR:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rockchip_i2s_tdm_precious_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	default:
+		return false;
+	}
+}
+
+static const struct reg_default rockchip_i2s_tdm_reg_defaults[] = {
+	{0x00, 0x7200000f},
+	{0x04, 0x01c8000f},
+	{0x08, 0x00001f1f},
+	{0x10, 0x001f0000},
+	{0x14, 0x01f00000},
+	{0x30, 0x00003eff},
+	{0x34, 0x00003eff},
+	{0x38, 0x00000707},
+};
+
+static const struct regmap_config rockchip_i2s_tdm_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = I2S_CLKDIV,
+	.reg_defaults = rockchip_i2s_tdm_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(rockchip_i2s_tdm_reg_defaults),
+	.writeable_reg = rockchip_i2s_tdm_wr_reg,
+	.readable_reg = rockchip_i2s_tdm_rd_reg,
+	.volatile_reg = rockchip_i2s_tdm_volatile_reg,
+	.precious_reg = rockchip_i2s_tdm_precious_reg,
+	.cache_type = REGCACHE_FLAT,
+};
+
+static struct rk_i2s_soc_data rk3308_i2s_soc_data = {
+	.softrst_offset = 0x0400,
+};
+
+static const struct of_device_id rockchip_i2s_tdm_match[] = {
+	{ .compatible = "rockchip,rk3308-i2s-tdm", .data = &rk3308_i2s_soc_data },
+	{},
+};
+
+static int of_i2s_resetid_get(struct device_node *node,
+			      const char *id)
+{
+	struct of_phandle_args args;
+	int index = 0;
+	int ret;
+
+	if (id)
+		index = of_property_match_string(node,
+						 "reset-names", id);
+	ret = of_parse_phandle_with_args(node, "resets", "#reset-cells",
+					 index, &args);
+	if (ret)
+		return ret;
+
+	return args.args[0];
+}
+
+static int rockchip_i2s_tdm_dai_prepare(struct platform_device *pdev,
+					struct snd_soc_dai_driver **soc_dai)
+{
+	struct snd_soc_dai_driver rockchip_i2s_tdm_dai = {
+		.probe = rockchip_i2s_tdm_dai_probe,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 2,
+			.channels_max = 8,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = (SNDRV_PCM_FMTBIT_S8 |
+				    SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_S20_3LE |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S32_LE),
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 2,
+			.channels_max = 8,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = (SNDRV_PCM_FMTBIT_S8 |
+				    SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_S20_3LE |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S32_LE),
+		},
+		.ops = &rockchip_i2s_tdm_dai_ops,
+	};
+
+	*soc_dai = devm_kmemdup(&pdev->dev, &rockchip_i2s_tdm_dai,
+				sizeof(rockchip_i2s_tdm_dai), GFP_KERNEL);
+	if (!(*soc_dai)) {
+		dev_err(&pdev->dev, "Failed to duplicate i2s_tdm_dai\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int rockchip_i2s_tdm_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct device_node *cru_node;
+	const struct of_device_id *of_id;
+	struct rk_i2s_tdm_dev *i2s_tdm;
+	struct snd_soc_dai_driver *soc_dai;
+	struct resource *res;
+	void __iomem *regs;
+	int ret;
+	int val;
+
+	ret = rockchip_i2s_tdm_dai_prepare(pdev, &soc_dai);
+	if (ret < 0)
+		return ret;
+
+	i2s_tdm = devm_kzalloc(&pdev->dev, sizeof(*i2s_tdm), GFP_KERNEL);
+	if (!i2s_tdm)
+		return -ENOMEM;
+
+	i2s_tdm->dev = &pdev->dev;
+
+	spin_lock_init(&i2s_tdm->lock);
+	i2s_tdm->bclk_fs = 64;
+	if (!of_property_read_u32(node, "rockchip,bclk-fs", &val)) {
+		if ((val >= 32) && (val % 2 == 0))
+			i2s_tdm->bclk_fs = val;
+	}
+
+	i2s_tdm->clk_trcm = I2S_CKR_TRCM_TXRX;
+	if (!of_property_read_u32(node, "rockchip,clk-trcm", &val)) {
+		if (val >= 0 && val <= 2) {
+			i2s_tdm->clk_trcm = val << I2S_CKR_TRCM_SHIFT;
+			if (i2s_tdm->clk_trcm)
+				soc_dai->symmetric_rates = 1;
+		}
+	}
+
+	if (i2s_tdm->clk_trcm) {
+		cru_node = of_parse_phandle(node, "rockchip,cru", 0);
+		i2s_tdm->cru_base = of_iomap(cru_node, 0);
+		if (!i2s_tdm->cru_base)
+			return -ENOENT;
+		of_id = of_match_device(rockchip_i2s_tdm_match, &pdev->dev);
+		if (!of_id || !of_id->data)
+			return -EINVAL;
+
+		i2s_tdm->soc_data = (struct rk_i2s_soc_data *)of_id->data;
+		i2s_tdm->soc_data->tx_reset_id = of_i2s_resetid_get(node, "tx-m");
+		if (i2s_tdm->soc_data->tx_reset_id < 0)
+			return -EINVAL;
+		i2s_tdm->soc_data->rx_reset_id = of_i2s_resetid_get(node, "rx-m");
+		if (i2s_tdm->soc_data->rx_reset_id < 0)
+			return -EINVAL;
+	}
+
+	i2s_tdm->tx_reset = devm_reset_control_get(&pdev->dev, "tx-m");
+	if (IS_ERR(i2s_tdm->tx_reset)) {
+		ret = PTR_ERR(i2s_tdm->tx_reset);
+		if (ret != -ENOENT)
+			return ret;
+	}
+
+	i2s_tdm->rx_reset = devm_reset_control_get(&pdev->dev, "rx-m");
+	if (IS_ERR(i2s_tdm->rx_reset)) {
+		ret = PTR_ERR(i2s_tdm->rx_reset);
+		if (ret != -ENOENT)
+			return ret;
+	}
+
+	i2s_tdm->hclk = devm_clk_get(&pdev->dev, "hclk");
+	if (IS_ERR(i2s_tdm->hclk))
+		return PTR_ERR(i2s_tdm->hclk);
+
+	ret = clk_prepare_enable(i2s_tdm->hclk);
+	if (ret)
+		return ret;
+
+	i2s_tdm->mclk_tx = devm_clk_get(&pdev->dev, "mclk_tx");
+	if (IS_ERR(i2s_tdm->mclk_tx))
+		return PTR_ERR(i2s_tdm->mclk_tx);
+
+	i2s_tdm->mclk_rx = devm_clk_get(&pdev->dev, "mclk_rx");
+	if (IS_ERR(i2s_tdm->mclk_rx))
+		return PTR_ERR(i2s_tdm->mclk_rx);
+
+	i2s_tdm->mclk_calibrate =
+		of_property_read_bool(node, "rockchip,mclk-calibrate");
+	if (i2s_tdm->mclk_calibrate) {
+		i2s_tdm->mclk_tx_src = devm_clk_get(&pdev->dev, "mclk_tx_src");
+		if (IS_ERR(i2s_tdm->mclk_tx_src))
+			return PTR_ERR(i2s_tdm->mclk_tx_src);
+
+		i2s_tdm->mclk_rx_src = devm_clk_get(&pdev->dev, "mclk_rx_src");
+		if (IS_ERR(i2s_tdm->mclk_rx_src))
+			return PTR_ERR(i2s_tdm->mclk_rx_src);
+
+		i2s_tdm->mclk_root0 = devm_clk_get(&pdev->dev, "mclk_root0");
+		if (IS_ERR(i2s_tdm->mclk_root0))
+			return PTR_ERR(i2s_tdm->mclk_root0);
+
+		i2s_tdm->mclk_root1 = devm_clk_get(&pdev->dev, "mclk_root1");
+		if (IS_ERR(i2s_tdm->mclk_root1))
+			return PTR_ERR(i2s_tdm->mclk_root1);
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+
+	i2s_tdm->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
+					    &rockchip_i2s_tdm_regmap_config);
+	if (IS_ERR(i2s_tdm->regmap))
+		return PTR_ERR(i2s_tdm->regmap);
+
+	i2s_tdm->playback_dma_data.addr = res->start + I2S_TXDR;
+	i2s_tdm->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	i2s_tdm->playback_dma_data.maxburst = 8;
+
+	i2s_tdm->capture_dma_data.addr = res->start + I2S_RXDR;
+	i2s_tdm->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	i2s_tdm->capture_dma_data.maxburst = 8;
+
+	atomic_set(&i2s_tdm->refcount, 0);
+	dev_set_drvdata(&pdev->dev, i2s_tdm);
+
+	pm_runtime_enable(&pdev->dev);
+	if (!pm_runtime_enabled(&pdev->dev)) {
+		ret = i2s_tdm_runtime_resume(&pdev->dev);
+		if (ret)
+			goto err_pm_disable;
+	}
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+			   I2S_CKR_TRCM_MASK, i2s_tdm->clk_trcm);
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &rockchip_i2s_tdm_component,
+					      soc_dai, 1);
+
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI\n");
+		goto err_suspend;
+	}
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM\n");
+		return ret;
+	}
+
+	return 0;
+
+err_suspend:
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		i2s_tdm_runtime_suspend(&pdev->dev);
+err_pm_disable:
+	pm_runtime_disable(&pdev->dev);
+
+	return ret;
+}
+
+static int rockchip_i2s_tdm_remove(struct platform_device *pdev)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(&pdev->dev);
+
+	pm_runtime_disable(&pdev->dev);
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		i2s_tdm_runtime_suspend(&pdev->dev);
+
+	if (!IS_ERR(i2s_tdm->mclk_tx))
+		clk_prepare_enable(i2s_tdm->mclk_tx);
+	if (!IS_ERR(i2s_tdm->mclk_rx))
+		clk_prepare_enable(i2s_tdm->mclk_rx);
+	if (!IS_ERR(i2s_tdm->hclk))
+		clk_disable_unprepare(i2s_tdm->hclk);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int rockchip_i2s_tdm_suspend(struct device *dev)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+
+	regcache_mark_dirty(i2s_tdm->regmap);
+
+	return 0;
+}
+
+static int rockchip_i2s_tdm_resume(struct device *dev)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0)
+		return ret;
+	ret = regcache_sync(i2s_tdm->regmap);
+	pm_runtime_put(dev);
+
+	return ret;
+}
+#endif
+
+static const struct dev_pm_ops rockchip_i2s_tdm_pm_ops = {
+	SET_RUNTIME_PM_OPS(i2s_tdm_runtime_suspend, i2s_tdm_runtime_resume,
+			   NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(rockchip_i2s_tdm_suspend,
+				rockchip_i2s_tdm_resume)
+};
+
+static struct platform_driver rockchip_i2s_tdm_driver = {
+	.probe = rockchip_i2s_tdm_probe,
+	.remove = rockchip_i2s_tdm_remove,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = of_match_ptr(rockchip_i2s_tdm_match),
+		.pm = &rockchip_i2s_tdm_pm_ops,
+	},
+};
+module_platform_driver(rockchip_i2s_tdm_driver);
+
+MODULE_DESCRIPTION("ROCKCHIP I2S/TDM ASoC Interface");
+MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DEVICE_TABLE(of, rockchip_i2s_tdm_match);
diff --git a/sound/soc/rockchip/rockchip_i2s_tdm.h b/sound/soc/rockchip/rockchip_i2s_tdm.h
new file mode 100644
index 000000000000..32a91ed85d4e
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_i2s_tdm.h
@@ -0,0 +1,276 @@
+/*
+ * sound/soc/rockchip/rockchip_i2s_tdm.h
+ *
+ * ALSA SoC Audio Layer - Rockchip I2S_TDM Controller driver
+ *
+ * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
+ * Author: Sugar Zhang <sugar.zhang@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _ROCKCHIP_I2S_TDM_H
+#define _ROCKCHIP_I2S_TDM_H
+
+/*
+ * TXCR
+ * transmit operation control register
+ */
+#define I2S_TXCR_RCNT_SHIFT	17
+#define I2S_TXCR_RCNT_MASK	(0x3f << I2S_TXCR_RCNT_SHIFT)
+#define I2S_TXCR_CSR_SHIFT	15
+#define I2S_TXCR_CSR(x)		(x << I2S_TXCR_CSR_SHIFT)
+#define I2S_TXCR_CSR_MASK	(3 << I2S_TXCR_CSR_SHIFT)
+#define I2S_TXCR_HWT		BIT(14)
+#define I2S_TXCR_SJM_SHIFT	12
+#define I2S_TXCR_SJM_R		(0 << I2S_TXCR_SJM_SHIFT)
+#define I2S_TXCR_SJM_L		(1 << I2S_TXCR_SJM_SHIFT)
+#define I2S_TXCR_FBM_SHIFT	11
+#define I2S_TXCR_FBM_MSB	(0 << I2S_TXCR_FBM_SHIFT)
+#define I2S_TXCR_FBM_LSB	(1 << I2S_TXCR_FBM_SHIFT)
+#define I2S_TXCR_IBM_SHIFT	9
+#define I2S_TXCR_IBM_NORMAL	(0 << I2S_TXCR_IBM_SHIFT)
+#define I2S_TXCR_IBM_LSJM	(1 << I2S_TXCR_IBM_SHIFT)
+#define I2S_TXCR_IBM_RSJM	(2 << I2S_TXCR_IBM_SHIFT)
+#define I2S_TXCR_IBM_MASK	(3 << I2S_TXCR_IBM_SHIFT)
+#define I2S_TXCR_PBM_SHIFT	7
+#define I2S_TXCR_PBM_MODE(x)	(x << I2S_TXCR_PBM_SHIFT)
+#define I2S_TXCR_PBM_MASK	(3 << I2S_TXCR_PBM_SHIFT)
+#define I2S_TXCR_TFS_SHIFT	5
+#define I2S_TXCR_TFS_I2S	(0 << I2S_TXCR_TFS_SHIFT)
+#define I2S_TXCR_TFS_PCM	(1 << I2S_TXCR_TFS_SHIFT)
+#define I2S_TXCR_TFS_TDM_PCM	(2 << I2S_TXCR_TFS_SHIFT)
+#define I2S_TXCR_TFS_TDM_I2S	(3 << I2S_TXCR_TFS_SHIFT)
+#define I2S_TXCR_TFS_MASK	(3 << I2S_TXCR_TFS_SHIFT)
+#define I2S_TXCR_VDW_SHIFT	0
+#define I2S_TXCR_VDW(x)		((x - 1) << I2S_TXCR_VDW_SHIFT)
+#define I2S_TXCR_VDW_MASK	(0x1f << I2S_TXCR_VDW_SHIFT)
+
+/*
+ * RXCR
+ * receive operation control register
+ */
+#define I2S_RXCR_CSR_SHIFT	15
+#define I2S_RXCR_CSR(x)		(x << I2S_RXCR_CSR_SHIFT)
+#define I2S_RXCR_CSR_MASK	(3 << I2S_RXCR_CSR_SHIFT)
+#define I2S_RXCR_HWT		BIT(14)
+#define I2S_RXCR_SJM_SHIFT	12
+#define I2S_RXCR_SJM_R		(0 << I2S_RXCR_SJM_SHIFT)
+#define I2S_RXCR_SJM_L		(1 << I2S_RXCR_SJM_SHIFT)
+#define I2S_RXCR_FBM_SHIFT	11
+#define I2S_RXCR_FBM_MSB	(0 << I2S_RXCR_FBM_SHIFT)
+#define I2S_RXCR_FBM_LSB	(1 << I2S_RXCR_FBM_SHIFT)
+#define I2S_RXCR_IBM_SHIFT	9
+#define I2S_RXCR_IBM_NORMAL	(0 << I2S_RXCR_IBM_SHIFT)
+#define I2S_RXCR_IBM_LSJM	(1 << I2S_RXCR_IBM_SHIFT)
+#define I2S_RXCR_IBM_RSJM	(2 << I2S_RXCR_IBM_SHIFT)
+#define I2S_RXCR_IBM_MASK	(3 << I2S_RXCR_IBM_SHIFT)
+#define I2S_RXCR_PBM_SHIFT	7
+#define I2S_RXCR_PBM_MODE(x)	(x << I2S_RXCR_PBM_SHIFT)
+#define I2S_RXCR_PBM_MASK	(3 << I2S_RXCR_PBM_SHIFT)
+#define I2S_RXCR_TFS_SHIFT	5
+#define I2S_RXCR_TFS_I2S	(0 << I2S_RXCR_TFS_SHIFT)
+#define I2S_RXCR_TFS_PCM	(1 << I2S_RXCR_TFS_SHIFT)
+#define I2S_RXCR_TFS_TDM_PCM	(2 << I2S_RXCR_TFS_SHIFT)
+#define I2S_RXCR_TFS_TDM_I2S	(3 << I2S_RXCR_TFS_SHIFT)
+#define I2S_RXCR_TFS_MASK	(3 << I2S_RXCR_TFS_SHIFT)
+#define I2S_RXCR_VDW_SHIFT	0
+#define I2S_RXCR_VDW(x)		((x - 1) << I2S_RXCR_VDW_SHIFT)
+#define I2S_RXCR_VDW_MASK	(0x1f << I2S_RXCR_VDW_SHIFT)
+
+/*
+ * CKR
+ * clock generation register
+ */
+#define I2S_CKR_TRCM_SHIFT	28
+#define I2S_CKR_TRCM(x)	(x << I2S_CKR_TRCM_SHIFT)
+#define I2S_CKR_TRCM_TXRX	(0 << I2S_CKR_TRCM_SHIFT)
+#define I2S_CKR_TRCM_TXONLY	(1 << I2S_CKR_TRCM_SHIFT)
+#define I2S_CKR_TRCM_RXONLY	(2 << I2S_CKR_TRCM_SHIFT)
+#define I2S_CKR_TRCM_MASK	(3 << I2S_CKR_TRCM_SHIFT)
+#define I2S_CKR_MSS_SHIFT	27
+#define I2S_CKR_MSS_MASTER	(0 << I2S_CKR_MSS_SHIFT)
+#define I2S_CKR_MSS_SLAVE	(1 << I2S_CKR_MSS_SHIFT)
+#define I2S_CKR_MSS_MASK	(1 << I2S_CKR_MSS_SHIFT)
+#define I2S_CKR_CKP_SHIFT	26
+#define I2S_CKR_CKP_NEG		(0 << I2S_CKR_CKP_SHIFT)
+#define I2S_CKR_CKP_POS		(1 << I2S_CKR_CKP_SHIFT)
+#define I2S_CKR_CKP_MASK	(1 << I2S_CKR_CKP_SHIFT)
+#define I2S_CKR_RLP_SHIFT	25
+#define I2S_CKR_RLP_NORMAL	(0 << I2S_CKR_RLP_SHIFT)
+#define I2S_CKR_RLP_OPPSITE	(1 << I2S_CKR_RLP_SHIFT)
+#define I2S_CKR_TLP_SHIFT	24
+#define I2S_CKR_TLP_NORMAL	(0 << I2S_CKR_TLP_SHIFT)
+#define I2S_CKR_TLP_OPPSITE	(1 << I2S_CKR_TLP_SHIFT)
+#define I2S_CKR_MDIV_SHIFT	16
+#define I2S_CKR_MDIV(x)		((x - 1) << I2S_CKR_MDIV_SHIFT)
+#define I2S_CKR_MDIV_MASK	(0xff << I2S_CKR_MDIV_SHIFT)
+#define I2S_CKR_RSD_SHIFT	8
+#define I2S_CKR_RSD(x)		((x - 1) << I2S_CKR_RSD_SHIFT)
+#define I2S_CKR_RSD_MASK	(0xff << I2S_CKR_RSD_SHIFT)
+#define I2S_CKR_TSD_SHIFT	0
+#define I2S_CKR_TSD(x)		((x - 1) << I2S_CKR_TSD_SHIFT)
+#define I2S_CKR_TSD_MASK	(0xff << I2S_CKR_TSD_SHIFT)
+
+/*
+ * FIFOLR
+ * FIFO level register
+ */
+#define I2S_FIFOLR_RFL_SHIFT	24
+#define I2S_FIFOLR_RFL_MASK	(0x3f << I2S_FIFOLR_RFL_SHIFT)
+#define I2S_FIFOLR_TFL3_SHIFT	18
+#define I2S_FIFOLR_TFL3_MASK	(0x3f << I2S_FIFOLR_TFL3_SHIFT)
+#define I2S_FIFOLR_TFL2_SHIFT	12
+#define I2S_FIFOLR_TFL2_MASK	(0x3f << I2S_FIFOLR_TFL2_SHIFT)
+#define I2S_FIFOLR_TFL1_SHIFT	6
+#define I2S_FIFOLR_TFL1_MASK	(0x3f << I2S_FIFOLR_TFL1_SHIFT)
+#define I2S_FIFOLR_TFL0_SHIFT	0
+#define I2S_FIFOLR_TFL0_MASK	(0x3f << I2S_FIFOLR_TFL0_SHIFT)
+
+/*
+ * DMACR
+ * DMA control register
+ */
+#define I2S_DMACR_RDE_SHIFT	24
+#define I2S_DMACR_RDE_DISABLE	(0 << I2S_DMACR_RDE_SHIFT)
+#define I2S_DMACR_RDE_ENABLE	(1 << I2S_DMACR_RDE_SHIFT)
+#define I2S_DMACR_RDL_SHIFT	16
+#define I2S_DMACR_RDL(x)	((x - 1) << I2S_DMACR_RDL_SHIFT)
+#define I2S_DMACR_RDL_MASK	(0x1f << I2S_DMACR_RDL_SHIFT)
+#define I2S_DMACR_TDE_SHIFT	8
+#define I2S_DMACR_TDE_DISABLE	(0 << I2S_DMACR_TDE_SHIFT)
+#define I2S_DMACR_TDE_ENABLE	(1 << I2S_DMACR_TDE_SHIFT)
+#define I2S_DMACR_TDL_SHIFT	0
+#define I2S_DMACR_TDL(x)	((x) << I2S_DMACR_TDL_SHIFT)
+#define I2S_DMACR_TDL_MASK	(0x1f << I2S_DMACR_TDL_SHIFT)
+
+/*
+ * INTCR
+ * interrupt control register
+ */
+#define I2S_INTCR_RFT_SHIFT	20
+#define I2S_INTCR_RFT(x)	((x - 1) << I2S_INTCR_RFT_SHIFT)
+#define I2S_INTCR_RXOIC		BIT(18)
+#define I2S_INTCR_RXOIE_SHIFT	17
+#define I2S_INTCR_RXOIE_DISABLE	(0 << I2S_INTCR_RXOIE_SHIFT)
+#define I2S_INTCR_RXOIE_ENABLE	(1 << I2S_INTCR_RXOIE_SHIFT)
+#define I2S_INTCR_RXFIE_SHIFT	16
+#define I2S_INTCR_RXFIE_DISABLE	(0 << I2S_INTCR_RXFIE_SHIFT)
+#define I2S_INTCR_RXFIE_ENABLE	(1 << I2S_INTCR_RXFIE_SHIFT)
+#define I2S_INTCR_TFT_SHIFT	4
+#define I2S_INTCR_TFT(x)	((x - 1) << I2S_INTCR_TFT_SHIFT)
+#define I2S_INTCR_TFT_MASK	(0x1f << I2S_INTCR_TFT_SHIFT)
+#define I2S_INTCR_TXUIC		BIT(2)
+#define I2S_INTCR_TXUIE_SHIFT	1
+#define I2S_INTCR_TXUIE_DISABLE	(0 << I2S_INTCR_TXUIE_SHIFT)
+#define I2S_INTCR_TXUIE_ENABLE	(1 << I2S_INTCR_TXUIE_SHIFT)
+
+/*
+ * INTSR
+ * interrupt status register
+ */
+#define I2S_INTSR_TXEIE_SHIFT	0
+#define I2S_INTSR_TXEIE_DISABLE	(0 << I2S_INTSR_TXEIE_SHIFT)
+#define I2S_INTSR_TXEIE_ENABLE	(1 << I2S_INTSR_TXEIE_SHIFT)
+#define I2S_INTSR_RXOI_SHIFT	17
+#define I2S_INTSR_RXOI_INA	(0 << I2S_INTSR_RXOI_SHIFT)
+#define I2S_INTSR_RXOI_ACT	(1 << I2S_INTSR_RXOI_SHIFT)
+#define I2S_INTSR_RXFI_SHIFT	16
+#define I2S_INTSR_RXFI_INA	(0 << I2S_INTSR_RXFI_SHIFT)
+#define I2S_INTSR_RXFI_ACT	(1 << I2S_INTSR_RXFI_SHIFT)
+#define I2S_INTSR_TXUI_SHIFT	1
+#define I2S_INTSR_TXUI_INA	(0 << I2S_INTSR_TXUI_SHIFT)
+#define I2S_INTSR_TXUI_ACT	(1 << I2S_INTSR_TXUI_SHIFT)
+#define I2S_INTSR_TXEI_SHIFT	0
+#define I2S_INTSR_TXEI_INA	(0 << I2S_INTSR_TXEI_SHIFT)
+#define I2S_INTSR_TXEI_ACT	(1 << I2S_INTSR_TXEI_SHIFT)
+
+/*
+ * XFER
+ * Transfer start register
+ */
+#define I2S_XFER_RXS_SHIFT	1
+#define I2S_XFER_RXS_STOP	(0 << I2S_XFER_RXS_SHIFT)
+#define I2S_XFER_RXS_START	(1 << I2S_XFER_RXS_SHIFT)
+#define I2S_XFER_TXS_SHIFT	0
+#define I2S_XFER_TXS_STOP	(0 << I2S_XFER_TXS_SHIFT)
+#define I2S_XFER_TXS_START	(1 << I2S_XFER_TXS_SHIFT)
+
+/*
+ * CLR
+ * clear SCLK domain logic register
+ */
+#define I2S_CLR_RXC	BIT(1)
+#define I2S_CLR_TXC	BIT(0)
+
+/*
+ * TXDR
+ * Transimt FIFO data register, write only.
+ */
+#define I2S_TXDR_MASK	(0xff)
+
+/*
+ * RXDR
+ * Receive FIFO data register, write only.
+ */
+#define I2S_RXDR_MASK	(0xff)
+
+/*
+ * TDM_CTRL
+ * TDM ctrl register
+ */
+#define TDM_FSYNC_WIDTH_SEL1_MSK	GENMASK(20, 18)
+#define TDM_FSYNC_WIDTH_SEL1(x)		((x - 1) << 18)
+#define TDM_FSYNC_WIDTH_SEL0_MSK	BIT(17)
+#define TDM_FSYNC_WIDTH_HALF_FRAME	0
+#define TDM_FSYNC_WIDTH_ONE_FRAME	BIT(17)
+#define TDM_SHIFT_CTRL_MSK		GENMASK(16, 14)
+#define TDM_SHIFT_CTRL(x)		((x) << 14)
+#define TDM_SLOT_BIT_WIDTH_MSK		GENMASK(13, 9)
+#define TDM_SLOT_BIT_WIDTH(x)		((x - 1) << 9)
+#define TDM_FRAME_WIDTH_MSK		GENMASK(8, 0)
+#define TDM_FRAME_WIDTH(x)		((x - 1) << 0)
+
+/*
+ * CLKDIV
+ * Mclk div register
+ */
+#define I2S_CLKDIV_TXM_SHIFT	0
+#define I2S_CLKDIV_TXM(x)		((x - 1) << I2S_CLKDIV_TXM_SHIFT)
+#define I2S_CLKDIV_TXM_MASK	(0xff << I2S_CLKDIV_TXM_SHIFT)
+#define I2S_CLKDIV_RXM_SHIFT	8
+#define I2S_CLKDIV_RXM(x)		((x - 1) << I2S_CLKDIV_RXM_SHIFT)
+#define I2S_CLKDIV_RXM_MASK	(0xff << I2S_CLKDIV_RXM_SHIFT)
+
+/* Clock divider id */
+enum {
+	ROCKCHIP_DIV_MCLK = 0,
+	ROCKCHIP_DIV_BCLK,
+};
+
+/* channel select */
+#define I2S_CSR_SHIFT	15
+#define I2S_CHN_2	(0 << I2S_CSR_SHIFT)
+#define I2S_CHN_4	(1 << I2S_CSR_SHIFT)
+#define I2S_CHN_6	(2 << I2S_CSR_SHIFT)
+#define I2S_CHN_8	(3 << I2S_CSR_SHIFT)
+
+/* I2S REGS */
+#define I2S_TXCR	(0x0000)
+#define I2S_RXCR	(0x0004)
+#define I2S_CKR		(0x0008)
+#define I2S_FIFOLR	(0x000c)
+#define I2S_DMACR	(0x0010)
+#define I2S_INTCR	(0x0014)
+#define I2S_INTSR	(0x0018)
+#define I2S_XFER	(0x001c)
+#define I2S_CLR		(0x0020)
+#define I2S_TXDR	(0x0024)
+#define I2S_RXDR	(0x0028)
+#define I2S_TDM_TXCR	(0x0030)
+#define I2S_TDM_RXCR	(0x0034)
+#define I2S_CLKDIV	(0x0038)
+
+#endif /* _ROCKCHIP_I2S_TDM_H */
diff --git a/sound/soc/rockchip/rockchip_multicodecs.c b/sound/soc/rockchip/rockchip_multicodecs.c
new file mode 100644
index 000000000000..94fc2f25cbe6
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_multicodecs.c
@@ -0,0 +1,227 @@
+/*
+ * Rockchip machine ASoC driver for Rockchip Multi-codecs audio
+ *
+ * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * Authors: Sugar Zhang <sugar.zhang@rock-chips.com>,
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/jack.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include "../codecs/rk3308_codec_provider.h"
+
+#define DRV_NAME "rk-multicodecs"
+#define MAX_CODECS	2
+#define DEFAULT_MCLK_FS	256
+
+struct multicodecs_data {
+	unsigned int mclk_fs;
+	bool codec_hp_det;
+};
+
+static struct snd_soc_jack mc_hp_jack;
+
+static int rk_multicodecs_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct multicodecs_data *mc_data = snd_soc_card_get_drvdata(rtd->card);
+	unsigned int mclk;
+	int ret;
+
+	mclk = params_rate(params) * mc_data->mclk_fs;
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, substream->stream, mclk,
+				     SND_SOC_CLOCK_IN);
+	if (ret && ret != -ENOTSUPP) {
+		pr_err("Set codec_dai sysclk failed: %d\n", ret);
+		goto out;
+	}
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, substream->stream, mclk,
+				     SND_SOC_CLOCK_OUT);
+	if (ret && ret != -ENOTSUPP) {
+		pr_err("Set cpu_dai sysclk failed: %d\n", ret);
+		goto out;
+	}
+
+	return 0;
+
+out:
+	return ret;
+}
+
+static int rk_dailink_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct multicodecs_data *mc_data = snd_soc_card_get_drvdata(rtd->card);
+
+	if (mc_data->codec_hp_det) {
+		snd_soc_card_jack_new(rtd->card, "Headphones",
+				      SND_JACK_HEADPHONE,
+				      &mc_hp_jack, NULL, 0);
+
+#ifdef CONFIG_SND_SOC_RK3308
+		rk3308_codec_set_jack_detect(rtd->codec, &mc_hp_jack);
+#endif
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops rk_ops = {
+	.hw_params = rk_multicodecs_hw_params,
+};
+
+static struct snd_soc_dai_link rk_dailink = {
+	.name = "MULTICODECS",
+	.stream_name = "MULTICODECS",
+	.init = rk_dailink_init,
+	.ops = &rk_ops,
+	.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBS_CFS,
+};
+
+static struct snd_soc_card snd_soc_card_rk = {
+	.name = "rk-multicodecs-sound",
+	.dai_link = &rk_dailink,
+	.num_links = 1,
+	.num_aux_devs = 0,
+};
+
+static int rk_multicodecs_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &snd_soc_card_rk;
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_dai_link *link = card->dai_link;
+	struct snd_soc_dai_link_component *codecs;
+	struct multicodecs_data *mc_data;
+	struct of_phandle_args args;
+	struct device_node *node;
+	u32 val;
+	int count;
+	int ret = 0, i = 0, idx = 0;
+
+	card->dev = &pdev->dev;
+
+	/* Parse the card name from DT */
+	ret = snd_soc_of_parse_card_name(card, "rockchip,card-name");
+	if (ret < 0)
+		return ret;
+
+	mc_data = devm_kzalloc(&pdev->dev, sizeof(*mc_data), GFP_KERNEL);
+	if (!mc_data)
+		return -ENOMEM;
+
+	count = of_count_phandle_with_args(np, "rockchip,codec", NULL);
+	if (count < 0 || count > MAX_CODECS)
+		return -EINVAL;
+
+	/* refine codecs, remove unavailable node */
+	for (i = 0; i < count; i++) {
+		node = of_parse_phandle(np, "rockchip,codec", i);
+		if (!node)
+			return -ENODEV;
+		if (of_device_is_available(node))
+			idx++;
+	}
+
+	if (!idx)
+		return -ENODEV;
+
+	codecs = devm_kcalloc(&pdev->dev, idx,
+			      sizeof(*codecs), GFP_KERNEL);
+	link->codecs = codecs;
+	link->num_codecs = idx;
+	idx = 0;
+	for (i = 0; i < count; i++) {
+		node = of_parse_phandle(np, "rockchip,codec", i);
+		if (!node)
+			return -ENODEV;
+		if (!of_device_is_available(node))
+			continue;
+
+		ret = of_parse_phandle_with_fixed_args(np, "rockchip,codec",
+						       0, i, &args);
+		if (ret)
+			return ret;
+
+		codecs[idx].of_node = node;
+		ret = snd_soc_get_dai_name(&args, &codecs[idx].dai_name);
+		if (ret)
+			return ret;
+		idx++;
+	}
+
+	link->cpu_of_node = of_parse_phandle(np, "rockchip,cpu", 0);
+	if (!link->cpu_of_node)
+		return -ENODEV;
+
+	link->platform_of_node = link->cpu_of_node;
+
+	mc_data->mclk_fs = DEFAULT_MCLK_FS;
+	if (!of_property_read_u32(np, "rockchip,mclk-fs", &val))
+		mc_data->mclk_fs = val;
+
+	mc_data->codec_hp_det =
+		of_property_read_bool(np, "rockchip,codec-hp-det");
+
+	snd_soc_card_set_drvdata(card, mc_data);
+
+	ret = devm_snd_soc_register_card(&pdev->dev, card);
+	if (ret == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	if (ret) {
+		dev_err(&pdev->dev, "card register failed %d\n", ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, card);
+
+	return ret;
+}
+
+static const struct of_device_id rockchip_multicodecs_of_match[] = {
+	{ .compatible = "rockchip,multicodecs-card", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, rockchip_multicodecs_of_match);
+
+static struct platform_driver rockchip_multicodecs_driver = {
+	.probe = rk_multicodecs_probe,
+	.driver = {
+		.name = DRV_NAME,
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = rockchip_multicodecs_of_match,
+	},
+};
+
+module_platform_driver(rockchip_multicodecs_driver);
+
+MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip General Multicodecs ASoC driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
-- 
2.11.0

